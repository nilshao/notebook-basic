# 第五章 传输层

## 概述

只有主机才有的层次

为应用层提供服务，使用网络层的服务。

功能

+ 传输层提供进程和进程之间的逻辑通信（网络层提供主机之间的逻辑通信）

+ 复用和分用：

+ 传输层对收到的报文进行差错检测。检测头部，因为内容在网络层中检测过了

两个协议：TCP（靠谱），UDP（不靠谱）
（文字补一下）（图片——

![传输层两个协议简介](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/传输层两个协议简介.png)

+ TCP：面向连接的传输控制协议：要先建立连接。可靠，面向连接，时延大，适用于大文件

+ UDP：无连接的用户数据报协议：不可靠，无连接，时延小，适用于小文件

### 传输层的寻址与端口

+ 复用：应用层所有的应用进程都可以通过传输层再传输到网络层

+ 分用：传输层从网络层收到数据后交付指明的应用进程

端口：指的是逻辑端口/软件端口，是传输层的SAP，标识主机中的应用进程。

端口号只有本地意义，在因特网中不同计算机的相同端口没有联系。

端口长度有16bit，能表示65536个不同的端口号

![传输层的寻址与端口1](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/传输层的寻址与端口1.png)

![传输层的寻址与端口2](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/传输层的寻址与端口2.png)

在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。

套接字（Socket）=（主机ip地址，端口号）

## UDP

### 概述

只在ip数据报服务上增加了很少功能，即复用分用和差错检测。

UDP的主要特点：

+ UDP是无连接的，减少开销和发送数据之前的时延

+ UDP使用最大努力交付，既不保证可靠交付。

+ UDP是面向报文的，适合一次性传输少量数据的网络应用

    应用层产生应用层报文 -> 传输层

    ![UDP概述](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/UDP概述.png)

    应用层给udp多长的报文，udp就照样发送，一次发一个完整报文

    如果太大量数据，网络层还要分片。

+ UDP没有拥塞控制，适合很多实时应用，比如ip电话等，不用拥塞控制，丢掉一点信息也ok，但不能有延迟

+ UDP首部开销小，8字节。TCP首部：20字节

### UDP首部格式

16位原端口号可有可无，目的端口号一定要有

UDP长度：整个（首部+数据）数据报的长度

UDP检验和：检测整个udp数据报是否有错，错就丢弃

分用时，找不到对应目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”的差错报文

![UDP报文首部格式](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/UDP报文首部格式.png)

### UDP校验

17: 封装udp报文的ip数据报首部协议字段是17。

伪首部只有在计算检验和时才出现，不想下传送也不向上递交。

udp长度：udp首部8B+数据部分长度（不包括伪首部）

![UDP校验伪首部](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/UDP校验伪首部.png)

### （用伪首部）进行UDP校验

![UDP校验2](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/UDP校验2.png)


## TCP协议

### TCP协议特点和TCP报文段

1. 面向连接（虚连接）的传输层协议，虚连接：先建立连接

2. 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点

3. TCP提供可靠交付的服务，无差错，不丢失，不重复，按序到达

4. TCP提供全双工通信：所以都设置发送缓存和接收缓存

    发送缓存：准备发送的数据，已经发送但没收到ACK的数据，
    
    接收缓存：按序到达但尚未被接受应用程序读取的数据，不按序到达的数据。

5. 面向**字节流**：TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流

    流：流入到进程或从进程流出的字节队列

### TCP报文段首部格式

![TCP报文首部格式](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/TCP报文首部格式.png)

序号：在一个TCP连接中传送的**字节流**中的每一个字节都按顺序编号,
本字段表示本报文段所发送数据的第一个字节的序号。

**确认号** 期望收到**对方下一个**报文段的第一个数据字节的序号。若确认号为N，
则证明到序号N-1为止的所有数据都已经正确收到

数据偏移（首部的长度）：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位，即1个数值是4B。这样就知道TCP数据部分从哪里开始。因为选项和填充字段长度不定



控制位：

+ **紧急位URG：** URG=1时，此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队。配合紧急指针字段使用。（发送方

+ **确认段ACK：** ACK=1时，确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。

+ 推送位PSH：PSH=1时，接收方尽快交付接受应用层，不再等到缓存填满再向上交付。（与URG区分：接收方

+ 复位层RST：RST=1时，表明TCP连接中出现严重差错，需要释放连接，重新建立传输连接

+ **同步位SYN：** SYN=1时，表明是一个连接请求/连接接受报文

+ **终止位FIN：** FIN=1时，表明此报文段发送方数据已发完，要求释放连接

窗口：16位两字节，指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。

紧急指针：URG=1时有意义，指出本报文段中紧急数据的字节数

检验和：检验首部+数据，检验时要加上12B伪首部，第四个字段为6

选项：最大报文长度MSS，窗口扩大，时间戳，选择确认。。。（internet发展后的一些新特点）

填充字段：为了使TCP报文首部是4字节的整数倍，选项可能不是4字节的整数倍

### TCP连接

TCP连接传输的三个阶段：连接建立，数据传输，连接释放。

#### 建立连接 

TCP连接的建立采用客户服务器方式，主动发动 连接建立的应用进程叫客户，等待连接建立的应用进程叫服务器。

假设运行在一台主机（客户）上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，
客户应用进程首先通知客户tcp，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接。

三次握手：

![三次握手](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/三次握手.png)

ROUND1: 客户端发送连接请求报文段，**无应用层数据**
    SYN=1，seq=x

ROUND2: 服务器为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据。
    SYN=1, ACK=1,seq=y,ack=x+1（小写ack是确认号）

ROUND3: 客户端为该TCP连接**分配缓存和变量**，并向服务器端返回确认的确认，可以携带数据
    SYN=1, ACK=1, seq=x+1, ack=y+1

SYN洪范攻击：

![SYN洪范攻击](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/SYN洪范攻击.png)

解决办法：设置SYN Cookie（了解）

#### 释放连接

参与一条TCP的两个进程中的任何一个都能终止该链接，连接结束后，主机中的“资源”（缓存和变量）将被释放。

![四次握手](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/四次握手.png)

ROUND1: 客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。
FIN=1，seq=u

ROUND2: 服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了（半关闭状态）

ACK=1, seq=v, ack=u+1

ROUND3: 服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接。

FIN=1，ACK=1，seq=w，ack=u+1s

ROUND4: 客户端会送一个确认报文段，再等到 时间等待计时器 设置的2MSL（最长报文段寿命）后，连接彻底关闭。

2MSL：万一服务器半关闭之后发送的报文有问题，还可以重置时间等待计时器、重传报文段，
（再看一下别的，如何确定2msl

### TCP可靠传输

TCP实现可靠传输的机制：校验，序号，确认，重传

+ 校验：和UDP校验一样，添加伪首部

+ 序号：“字节流” 一个字节占一个序号，序号字段指的是一个报文段第一个字节的序号。

+ 确认：报文段首部“确认号”

+ 重传：超时重传，TCP的发送方在规定时间内没有收到确认就要重传已发送的报文段。

    * TCP采用自适应算法，动态改变重传时间RTTs（加权平均往返时间）。

    * 冗余ACK：每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。
    例子：发送方发送1，2，3，4，5报文段。接收方收到1，返回给1的确认，（没收到2），收到3，返回1的确认，收到4，5仍返回1的确认。发送方收到三个对于报文段1的冗余ACK，认为2报文段丢失，重传2号报文段。称为**快速重传**

### TCP流量控制

![TCP流量控制](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/TCP流量控制.png)

让发送方发慢点，让接收方来得及接收。

TCP利用滑动窗口机制实现流量控制。

在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，
即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），
发送方的发送窗口 取 接受窗口rwnd 和 拥塞窗口cwnd 的最小值。

rwnd：接收方根据接收缓存设置的值，并告知给发送方，反映接收方容量。

cwnd：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。

TCP为每一个连接设有一个持续计时器，只要tcp连接的一方收到对方的零窗口通知，就启动持续计时器。

若持续计时器设置的时间到期，就发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值。

若窗口仍为0，那么发送方就重新设置持续计时器。

### TCP拥塞控制

出现拥塞：对资源需求的总和 > 可用资源（网络中的链路容量，带宽；交换节点中的缓存，处理机等）

网络中有许多资源同时呈现供应不足 -> 网络性能变坏 -> 网络吞吐量将随输入负荷增大而下降

拥塞控制：防止过多数据注入到网络

拥塞控制&流量控制：拥塞控制是全局问题，拥塞控制是一个点到点问题，如果流量大就让发送方不要发

四种算法：

+ 假定：
    
    * 模型只看做数据单方向传送，另一方只传送确认
    
    * 接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度。

+ 慢开始和拥塞避免算法

![慢开始](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/慢开始.png)


拥塞窗口以一个报文段长度MSS为单位。

一个传输轮次：发送了一批报文段并收到他们的确认的时间。
也指一个往返时延RTT。
也可以定义为开始发送一批拥塞窗口内的报文段 到开始发送下一批拥塞窗口内的报文段的时间。

ssthresh：slow start threshold 慢开始阈值。加法增大以拥塞避免。进入“慢开始”

到达网络拥塞之后，瞬间减少到“1个报文段”

设置新的ssthresh：发生网络拥塞时，把当时的拥塞窗口除以二作为新的ssthresh。或者加三除以二？？？（看看其他资料


+ 快重传和快恢复：

![快重传和快恢复](https://github.com/nilshao/cpp-notebook/raw/master/internet/pictures/chapter05/快重传和快恢复.png)

快恢复不用从慢开始的1个报文段大小开始，而是直接从新的ssthresh。
