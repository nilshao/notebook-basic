# 第二章 第一节 进程和线程

## 进程的定义，组成，组织方式，特征

* 在计算机发展史上，“进程”是为了解决什么问题而被引入的？

* 每个进程由哪些部分组成

* 系统中各个进程之间是如何被组织起来的？

* 相比于程序，进程有哪些特征

## 进程的定义，进程与程序

程序：就是一个指令序列

早期的计算机只支持单道程序，内存：程序的代码放在程序段内，低地址，程序运行过程处理的数据放在数据段内（如变量），高地址。

**多道程序技术：** 引入多道程序技术后：内存中同时放入多道程序，各个程序的代码，运算数据存放的位置不同，操作系统如何找到各个程序的存放位置？


**PCB：** 系统为每个运行的程序配置一个数据结构，称为**进程控制块（PCB）**，用来描述进程的各种信息（如程序代码存放位置）

为了方便操作系统管理，完成各个程序并发执行，引入了进程、进程实体的概念。**PCB、程序段、数据段**三部分构成进程实体（进程映像），一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。

PCB是进程存在的唯一标志！！！

进程的典型定义方式：“动态性”

1. 进程是程序的一次执行过程

2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动

3. 进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位

引入进程实体的概念后，可把进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的，不过一般也不区分。

### PCB的组成：



![PCB组成](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/PCB组成.jpeg)

进程描述信息

进程标识符PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程（类似于身份证号）

寄存器值：当进程切换时需要把进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示当前程序执行到哪一句

## 进程的组织

在一个系统中通常有数十数百个PCB，如何有效组织多个线程

![进程的组织方式](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程的组织方式.jpeg)

### 链接方式

1. 执行指针：指向当前处于运行状态（执行态）的进程

2. 就绪队列指针：指向当前处于就绪态的进程，通常会把优先级高的进程放在队头

3. 阻塞队列指针：指向当前处于阻塞态的进程，很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列

### 索引方式

建立相应功能的索引表

![索引方式](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/索引方式.jpeg)

## 进程的特征

![进程的基本特征](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程的基本特征.jpg)

动态性是进程最基本的特征

**进程是资源分配，接受调度的基本单位**

异步性会导致并发程序执行结果的不确定性

## 进程的状态

进程是运行的一次执行，在这个执行过程中，有时进程正在被CPU处理，有时等待CPU服务，可见进程状态会发生变化，为了方便对各个进程的管理，操作系统需要将进程合理划分为多种状态。

1. **运行状态Running（三种基本状态）：** **占有CPU**，在CPU上运行。

    单核处理机环境下，则每一时刻最多只有一个进程处于运行态，双核则可以同时有两个进程处于运行态。。。

2. **就绪态Ready（三种基本状态）：** 已经具备运行条件，但由于没有空闲CPU，暂时不能运行。

    就绪态下进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。

3. **阻塞态（等待态）Waiting/Blocked（三种基本状态）：** 因等待某一事件暂时不能运行。

    如：等待操作系统分配打印机，读写操作等，由于CPU资源最宝贵，所以处理完别的先再进入就绪态等待

4. **创建态：New** 操作系统需要完成创建进程，操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB

5. **终止态：Terminated** 进程运行结束，操作系统需要完成撤销进程相关的工作，完成将分配给进程的资源回收，撤销PCB等操作

### 进程状态的转换

![进程状态的转换](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程状态的转换.jpeg)

### 进程状态总结

![进程状态总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程状态总结.jpeg)

## 进程控制

进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现进程状态转换功能。

即：实现**进程转换** 

![进程控制1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程控制1.PNG)

**原语**控制：用原语实现进程控制，特点是执行期间不允许中断，必须一气呵成。这种不可以被中断的操作即被称为原子操作。原语采用“关中断指令”和“开中断指令”实现。只允许在核心态下执行的特权指令。

进程控制相关的原语，不论哪种原语，基本思路：

1. 更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）

    * 所有的进程控制原语一定都会修改进程状态标志

    * 剥夺当前运行进程的CPU使用权必然要保存其运行环境

    * 某进程开始运行前必然要恢复其运行环境

2. 将PCB插入合适队列

3. 分配/回收资源

如：

![进程的创建](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程的创建.jpeg)

![进程的终止](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程的终止.jpeg)

![进程的阻塞和唤醒](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程的阻塞和唤醒.jpeg)

阻塞：运行态到阻塞态；唤醒：阻塞态到运行态

阻塞原语唤醒原语必须成对使用

![进程的切换](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程的切换.jpeg)

## 进程通信

![进程通信1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程通信1.jpeg)

进程通信就是进程之间的信息交换，进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。

为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是有时进程之间的通信是必要的。因此需要进程间的安全通信

![进程通信2](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程通信2.jpeg)

### 共享存储

“共享空间”但是两个进程对共享空间的访问必须是**互斥**的，

![共享存储](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/共享存储.jpeg)


共享存储分为两种：

1. 基于**数据结构**的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多、是一种低级通信的方式

2. 基于**存储区**的共享：在内存中划出一块共享存储区，数据形式、存储位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。

### 管道通信

![管道通信](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/管道通信.jpeg)

管道是指用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的**缓冲区**。

1. 管道只能采用半双工通信，某一时间段内只能实现单向传输，如果要实现双向同时通信，需要设置两个管道。

2. 各个进程需要互斥地访问管道。

3. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走，当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。

4. 如果没写满，就不允许读，如果没读空，就不允许写。

5. 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。

### 消息传递

进程之间的数据交换以格式化信息（Message）为单位，进程通过操作系统的“发送消息/接收消息“两个原语进行数据交换。

![消息传递](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/消息传递.jpeg)

### 总结

![进程通信总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程通信总结.jpeg)

## 线程

### 线程的概念

什么是线程：

在进程中，进程是程序的一次执行，传统的进程是程序执行流的最小单位，但这些功能不可能是由同一个程序顺序处理就能实现的。引入线程来增加并发度，引入线程后线程成为了**程序执行流**的最小单位。

线程是一个基本的**CPU执行单元**，也是程序执行流的最小单位。引入线程后不仅是各进程之间可以并发，进程中的线程之间也可以并发，进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务。

引入线程后，进程只作为除cpu之外的系统资源的分配单元（如打印机/内存地址空间都是分配给进程的）。

引入线程后的变化

![线程和进程1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/线程和进程1.png)

### 线程的属性

* 线程是处理机调度的基本单位，多CPU计算机中，各个线程可以占用不同的CPU
  
* 每个线程都有一个线程ID，**线程控制块（TCB）**

* 线程也有就绪、阻塞、运行三种基本状态

* 线程几乎**不拥有系统资源**，他们的系统来自于所在的进程，同一进程的不同线程之间共享进程的资源，由于共享内存地址空间，同一进程中的线程间的通信甚至无需系统干预

* 同一进程中的线程切换，不会引起进程切换；不同进程中的线程切换，会引起进程切换：切换同进程内的线程，系统开销很小，切换进程，系统开销较大。

### 线程的实现方式

1. 用户级线程ULT（user-level-thread）

	用户级线程通过线程库实现，所有的线程管理都由应用程序负责（包括线程切换）。用户级线程中，线程切换在用户态下即可完成，无需操作系统干预。在用户看来有多个线程，但是在操作系统内核看来，并意识不到线程的存在，即用户级线程对用户不透明，对操作系统透明。

![用户级线程](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/用户级线程.png)

2. 内核级线程KLT（kernel-level-thread）

	内核级线程管理工作由操作系统内核完成。 线程调度、切换等工作都由内核负责，因此内核级线程切换必然需要在核心态下才能完成。

![内核级线程](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/内核级线程.png)

在同时支持用户级线程和内核级线程的操作系统中，采用二者组合的方式，将n个用户映射到m个内核级线程上。（n >=m )

操作系统只能看得见内核级线程，因此只能内核级线程才是处理机分配的单位。


### 多线程模型

在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型问题”。
注：内核级：物理结构，用户级：逻辑结构

* 多对一模型

	多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程。

	优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。

	缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上运行

* 一对一模型：

	一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程。

	优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可以在多核处理机上并行执行

	缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

* 多对多模型

	n个用户级线程映射到m个内核级线程（n>=m)，每个用户进程对应m个内核级线程

	克服了多对一模型并发度不高的缺点，也克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。





















