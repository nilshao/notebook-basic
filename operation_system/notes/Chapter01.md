# 第一章

## 操作系统的概念

1. 负责管理协调硬件、软件等计算机资源的工作

2. 为上层的应用程序，用户提供简单易用的服务。

3. 操作系统是系统软件，不是硬件

定义：指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境。它是计算机系统中最基本的系统软件

## 操作系统的功能和目标

![操作系统介绍1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/操作系统介绍1.jpeg)

1. 操作系统作为系统资源的管理者，包括软件，硬件，文件等，需要提供什么功能？

2. 操作系统作为用户与计算机硬件之间的接口，需要为其上层用户、应用程序提供简单易用的服务，需要什么功能？

3. 操作系统作为最接近硬件的层次，需要在纯硬件的基础上实现什么功能？

### 1.作为系统资源的管理者：

进程是一个程序的执行过程，执行前需要将该程序放到内存中，才能被CPU处理。


![系统资源管理1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/系统资源管理1.jpeg)

例子：QQ聊天

1. 在各个文件夹中找到QQ安装的位置：文件管理功能

2. 把该程序相关数据放入内存：存储器管理功能

3. 对应的进程被处理机（CPU）处理： 处理机管理功能

4. 开始和朋友聊天，调用摄像头：设备管理功能

### 2.作为用户与计算机硬件之间的接口

![作为用户与计算机硬件之间的接口](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/作为用户与计算机硬件之间的接口.jpeg)

用户接口：

![用户接口](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/用户接口.jpeg)

联机命令接口：windows中win+R

脱机命令接口实例：windows中 *.bat文件，批处理

程序接口：.dll，只能通过用户程序间接使用。

GUI：图形用户界面Graphical User Interface，用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。Windows，Android，IOS等。

### 3.作为最接近硬件的层次

需要实现对硬件机器的拓展，没有任何软件支持的计算机成为裸机，在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。通常把覆盖了软件的机器称为扩充机器，又称为虚拟机。

## 操作系统的四个特征

并发，共享，虚拟，异步。

**并发**和**共享**是两个最基本的特征，二者互相是存在条件

**并发：** 两个或多个事件在同一时间间隔内发生，这些事件宏观上是同时发生，但微观上是交替发生的。

操作系统的并发性指计算机系统中同时存在着多个运行着的程序。

一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替进行（这些程序微观上是交替执行的，但宏观上就像是同时执行），事实上操作系统就是伴随着“多道程序技术“出现的，因此，操作系统和程序并发是一起诞生的。

**共享：** 资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。

两种资源共享方式：

* 互斥共享：系统中某些资源，虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程访问该资源

* 同时共享：系统中某些资源，允许一个时间段内多个进程同时对他们进行访问。（但在微观上这些进程也可能是交替对资源进行访问：分时共享）

并发性是指计算机系统中同时存在多个运行中的程序。

共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。

**虚拟：** 把一个物理上的实体变为若干个逻辑上的对应物，物理实体是实际存在的，而逻辑上对应物是用户感受到的

虚拟技术中的 *时分复用（虚拟处理器）*，*空分复用（虚拟存储器技术）*

显然如果失去并发性，则一个时间段内系统中只能运行一道程序，就失去了实现虚拟性的意义。因此没有并发性就没有虚拟性。

**异步：** 在多道程序环境下，允许多个程序并发执行，但由于**资源**有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进。

如果失去并发性，系统智能串行地执行各个进程。每个进程的执行只能一贯到底，只有系统拥有并发性，才有可能导致异步性。

## 操作系统的发展和分类

1. 手工操作阶段：打纸带

2. 批处理阶段：单道批处理系统

	引入脱机输入输出技术（磁带），并**监督程序**控制作业的输入，输出————操作系统的雏形
	
3. 批处理阶段：多道批处理

	每次往内存输入多道程序，操作系统正式诞生，并引入了**中断技术**，由操作系统负责管理这些程序的运行，优点：各个程序并发执行，多道程序并发执行，共享计算机资源，资源利用率大幅提升，系统吞吐量增大。缺点：用户相应长，没有人机交互，用户提交自己作业之后就只能等待计算机处理完成，中间不能控制自己作业。

4. 分时操作系统

	计算机以时间片为单位轮流为各个用户/作业服务，各个用户可以通过终端与计算机进行交互。优点：用户请求可以被及时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人存在。缺点：不能优先处理一些紧急任务，操作系统对各个用户/作业完全平等。

5. 实时操作系统

	优点：能够优先响应一些紧急任务。某些紧急任务不需时间片排队
在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且在严格的时间限制内处理完事件。实时操作系统的主要特点是及时性和可靠性。

	实时操作系统分为两种：

	* 硬实时操作系统：必须在绝对严格的规定时间内完成处理

	* 软实时操作系统：能接受偶尔违反时间规定

6. 其他几种操作系统：

	* 网络操作系统：实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。

	* 分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务

	* 个人计算机操作系统

## 操作系统的运行机制和体系结构

什么是**指令**：代码翻译成机器语言指令，指令就是处理器CPU能够识别，执行的最基本命令

### 两种指令

* 特权指令：如内存清零指令，不允许用户程序执行

* 非特权指令：如普通的运算指令

CPU如何判断当前是否可以执行特权指令？规定两种处理器状态

### 两种处理器状态

用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态。0表示用户态，1表示核心态

* 用户态（目态）：此时CPU只能执行非特权指令

* 核心态（管态）：特权指令、非特权指令都可执行

### 两种程序

* 内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态

* 应用程序：为了保证系统能够安全运行，普通应用程序只能执行非特权指令，运行在用户态


### 操作系统的内核

![操作系统的内核](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/操作系统的内核.png)

内核是计算机上配置的底层**软件**，是操作系统最基本、最核心的部分，实现操作系统内核功能的那些程序就是内核程序

![操作系统的内核程序](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/操作系统的内核程序.png)


### 操作系统的体系结构

大内核和微内核

![大内核和微内核](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/大内核和微内核.png)

## 中断和异常

中断机制的诞生：早起电脑只能串行执行程序，系统资源利用率低。为了解决这个问题，发明了操作系统，作为计算机的管理者，引入中断机制，实现了多道程序**并发执行**。本质：发生中断就意味着需要操作系统介入，开展管理工作

### 中断的概念和作用

1. 中断发生时，CPU立即进入**核心态**

2. 中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理

3. 对于不同的中断信号，会进行不同的处理

发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行

问题：**用户态、核心态之间的切换**是怎么实现的？

答：用户态->核心态 是通过中断实现的，并且中断是**唯一**途径。

核心态->用户态 的切换是通过执行一个特权指令，将程序状态字PSW的标志位设置为用户态

### 中断的分类

两种分类方式

![中断的分类1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/中断的分类1.png)

另一种分类方式：

![中断的分类2](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/中断的分类2.png)


### 外中断的处理过程

![外中断的处理过程](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/外中断的处理过程.png)

**Step1:** 执行完每个指令之后,CPU都要检查当前是否有外部中断信号
**Step2:** 如果检测到外部中断信号,则需要保护被中断进程的CPU环境(如程序状态字PSW、程序计数器PC、各种通用寄存器)
**Step3:** 根据中断信号类型转入相应的中断处理程序
**Step4:** 恢复原进程的CPU环境并退出中断,返回原进程继续往下执行

## 系统调用

### 什么是系统调用

操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口，其中，程序接口由一组**系统调用**组成

“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。

应用程序通过系统调用操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源相关的操作（如存储分配，IO操作，文件管理等）都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。


系统调用相关处理涉及到对系统资源的管理，对进程的控制等，这些功能需要一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行

![系统调用](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/系统调用.png)

### 系统调用和库函数

![系统调用与库函数](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/系统调用与库函数.png)

当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用。

### 系统调用背后的过程

传递系统调用参数 -> 执行**陷入**指令（用户态） -> 执行系统调用相应服务程序（核心态） -> 返回用户程序

注意：

1. 陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态
	**陷入指令（Traps）**，又叫做自陷指令或访管指令，出现在计算机操作系统中，用于实现在用户态下运行的进程调用操作系统内核程序，即当运行的用户进程或系统实用进程欲请求操作系统内核为其服务时，可以安排执行一条陷入指令**引起一次特殊异常**。

2. 发出系统调用请求是在用户态，而对系统调用的相应处理实在核心态下进行

3. 陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。
