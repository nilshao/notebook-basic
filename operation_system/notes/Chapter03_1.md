# 第三章 第一节 内存

## 内存概念

内存是用于存放数据的硬件，程序执行前需要先放到内存中才能被CPU处理

于是：在多道程序环境下，系统中多个进程并发执行，多个程序的数据需要同时放到内存中，如何区分各个程序的数据需要放到什么地方？

方法：给内存的存储单元变地址，内存地址从0开始，每个地址对应一个存储单元

如果计算机”按字节编址“，则每个存储单元大小为一字节，1B，即8个二进制位

如果”按字编址“，每个存储单元大小为1个字，字长十六位的计算机中每个字的大小为16个二进制位。


![内存介绍1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/内存介绍1.jpeg)

## 进程的运行原理：指令

![指令](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/指令.jpeg)

相对地址=逻辑地址，绝对地址=物理地址


## 从写程序到运行

![从写程序到运行](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/从写程序到运行.jpeg)

装入模块中的地址指的是“相对地址”，但是装入模块装入内存时，需要对指令中的地址进行处理。装入的三种方式（由三种不同的方法完成逻辑地址到物理地址的转换）：

1. 绝对装入 
2. 静态重定位
3. 动态重定位


### 绝对装入

在编译时，如果知道程序将放入内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。

绝对装入只适用于单道程序环境。程序中使用的绝对地址可以在编译或汇编时给出，也可由程序猿直接赋予。

### 静态重定位

又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址。

静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存就不能再移动，也不能再申请内存空间。

### 动态重定位

动态重定位又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行，这种方式需要一个重定位寄存器的支持。

采用动态重定位时允许程序在内存中发生移动。并且可以将程序分配到不连续的存储区中，在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存。


## 内存管理

* 操作系统负责内存的分配和回收

* 操作系统需要提供某种技术从逻辑上对内存空间进行扩充（虚拟内存）

* 操作系统需要提供地址转换功能，负责程序的逻辑地址和物理地址的转换

* 操作系统提供内存保护功能，保证各个进程在各自存储空间内运行，互不干扰

	内存保护两种方法：

	1. 在cpu中设置一堆上下限寄存器，存放进程的上下限地址。进程的指令要访问某个地址时，cpu检查是否越界

	2. 重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）进行越界检查，分别存放起始地址和长度

## 内存空间的扩充：覆盖和交换

![覆盖和交换](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/覆盖和交换.jpeg)

### 覆盖技术

思想：把程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时放入内存。需要常驻内存的段放在固定区，不常用的段放在覆盖区。内存中分为一个固定区和多个覆盖区。

![覆盖技术](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/覆盖技术.jpeg)

### 交换技术

内存空间紧张时，系统将内存中某些进程暂时换出到外存，把外存中某些已具备运行条件的进程换入到内存


暂时换出到外存等待的进程状态为挂起状态suspend

挂起状态可进一步细分为就绪挂起和阻塞挂起

问题：

1. 应该在外存的什么位置保存被换出的进程？

2. 什么时候交换？

3. 换出哪些进程？

（补全文字）

![交换技术](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/交换技术.jpeg)

1. 具有兑换功能的操作系统中，通常把磁盘空间分为文件区和对换区

2. 

3. 

但是pcb会常驻内存，不会被换出外存

## 连续分配式管理

连续分配：为用户进程分配的必须是一个连续的内存空间

### 单一连续分配

![单一连续分配](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/单一连续分配.jpeg)


### 固定分区分配

将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一个作业。
有两种策略：
分区大小相等/分区大小不等。

分区大小相等：缺乏灵活性，但是适合用于用一台计算机控制多个相同对象的场合。

分区大小不等：增加灵活性，满足不同大小的进程需求。

如何记录空闲/分配情况：分区说明表，每个表项包括对应分区的大小，起始地址，状态。


优点：简单，无外部碎片

缺点：内部碎片；万一某个用户程序太大，分区不能满足需求


### 动态分区分配

进程装入内存时，根据进程的大小动态建立分区。

1. 操作系统要用什么样的数据结构记录内存的使用情况？

	空闲分区表：分区区号，分区大小，起始地址，分区状态

	空闲分区链：双向链表。每个分区的起始和末尾部分分别设置前向指针和后向指针。起始部分处还可以记录分区大小等信息

2. 当很多空闲分区都能满足需求时，应该选择哪个分区进行分配

	动态分区分配算法，

3. 动态分区的回收操作

	合并相邻的空闲分区，新增表项。。。


动态分区分配没有内部碎片，但是有外部碎片

内部碎片：分配给某进程的内存区域，有某些部分没有用上

外部碎片：内存中某些空闲分区由于太小而难以利用。“紧凑技术”


### 动态分区分配算法

![动态分区分配算法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/动态分区分配算法.jpeg)

1. 首次适应算法

	每次都从低地址开始查找，找到第一个能满足大小的空闲分区。

	空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区链（空闲分区表）

2. 最佳适应算法

	优先使用更小的空闲区。空闲分区按容量递增次序链接，每次分配内存时顺序查找空闲分区链（表），找到能满足大小要求的第一个分区

	缺点：留下很多难以利用的碎片，产生很多外部碎片

3. 最坏适应算法

	又称最大适应算法：为了解决分配留下太多难以利用的小碎片，可以每次都优先使用最大的连续空闲区。

	缺点：每次都利用较大的空闲区，如果后续有大进程到达就没有内存分区可用

4. 临近适应算法

	每次分配查找时都从上次超找结束的位置开始检索，（空闲分区排成循环链表）


比较：

![动态分区分配算法比较](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/动态分区分配算法比较.jpeg)



## 非连续分配方式：基本分页存储管理

考虑支持多道程序的两种连续分配方式：
固定分区分配，动态分区分配都有缺点。

如果允许将一个进程分散地放入许多不相邻分区，则可以充分利用内存。即“非连续分配方式”，或称为“离散分配方式”。

**基本分页存储管理**，基本分段存储管理，段页式存储管理。

### 基本分页存储管理：

把内存分为一个个相等的小分区，再按照分区大小把进程分成一个个小部分。

内存空间分为的分区称为页框（页帧，内存块，物理块），编号从0开始。页框也不宜过大，否则内部碎片太大。操作系统以页框为单位给各个进程分配空间。

### 如何实现地址转换（物理地址和逻辑地址之间）

1. 页号：除法取整数部分

2. 页内偏移量

3. 页面在内存中的起始位置

4. 物理地址 = 页面地址 + 页内偏移量


### 页表

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表

![页表](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/页表.jpeg)

每个页表项的长度是相同的，页号是隐含的。（说不明白就不要说）

## 基本地址变换机构

用于实现逻辑地址到物理地址转换的一组硬件结构。可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。

进程未执行时，页表的起始地址和页表长度放在进程控制模块PCB中，进程被调度时，操作系统内核会把它们放到页表寄存器中。

![基本地址变换机构](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/基本地址变换机构.png)

 
![基本地址变换机构总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/基本地址变换机构总结.png)

## 具有快##表的地址变换结构

### 局部性原理：

时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很可能再次执行，如果某个数据被访问后，不久后这个数据很可能会被再次访问

空间局部性：一旦程序访问了某个存储单元，不久之后其附近的存储单元可能也被访问（因为很多数据在内存之中都是连续存放的） 

因此在之前的基本地址变换机构中，可能连续很多次查询同一个页表项

### 快表TLB：

又称**联想寄存器**，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此相对，**内存**中的页表称为慢表。

![快表TLB](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/快表TLB.jpeg)


快表中存放的是页表的一部分副本，若快表命中就不需要再访问内存。

### 引入快表之后，地址的变换过程

![引入快表之后地址的变换过程](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/引入快表之后地址的变换过程.jpeg)

### 总结

![快表总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/快表总结.jpeg)

## 两级页表

### 单级页表的问题

![单级页表的问题](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/单级页表的问题.jpeg)

根据局部性原理，很多时候进程在一段时间内只需要访问某几个页面就可以正常运行了，没有必要让整个页表都常驻内存。

问题：

1. 页表必须连续存放,因此当页表很大时,需要占用很多个连续的页框。 
2. 没有必要让整个页表常驻内存,因为进程在一段时间内可能只需要访问某几个特定的页面。

### 如何解决单级页表的问题1 

可将长长的页表进行分组,使每个内存块刚好可以放入一个分组。

另外,要为离散分配的页表再建立一张页表,称为页目录表,或称外层页表,或称顶层页表。

**如何实现地址变换**

1. 按照地址结构将逻辑地址拆分成三部分
2. 从PCB中读出页目录表始址,再根据一级页号査页日 录表,找到下一级页表在内存中的存放位置
3. 根据二级页号査表,找到最终想访问的内存块号
4. 结合页内偏移量得到物理地址

### 如何解决单级页表的问题2

可以在需要访问页面时才把页面调入内存(虚拟存储技术)。可以 在页表项中增加一个标志位,用于表示该页面是否已经调入内存。

若想访问的页面不在内存中,则 产生缺页中断(内中断),然后 将目标页面从外存调入内存

### 总结

![两级页表总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/两级页表总结.jpeg)

## 基本分段存储管理

**分段**和分页的区别就是离散分配地址空间的基本单位不同。

段的大小不一，因为是**逻辑**上的划分

段表：段的映射表

![分段分页](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/分段分页.jpeg)

而且：
分段比分页更容易实现信息的共享和保护

![分段分页2](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/分段分页2.jpeg)

页是信息的物理单位。分页的主要目的是为了实现离散分配,提高内存利用率。分页仅仅是系统管 理上的需要,完全是系统行为,对用户是不可见的。
段是信息的逻辑单位。分页的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻 辑模块的信息。分段对用户是可见的,用户编程时需要显式地给出段名。 页的大小固定且由系统决定。段的长度却不固定,决定于用户编写的程序。 分页的用户进程地址空间是一维的,程序员只需给出一个记忆符即可表示一个地址
分段的用户进程地址空间是二维的,程序员在标识一个地址时,既要给出段名,也要给出段内地址 分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码(不属于临 界资源),这样的代码是可以共享的。可修改的代码是不能共享的 

访问一个逻辑地址需要几次访存?

分页(单级页表):第一次访存ー一査内存中的页表,第二次访存ーー访问目标内存单元。总共两次访存

分段:第一次访存ー一査内存中的段表,第二次访存一一访问目标内存单元。总共两次访存。与分页系统类似,分段系统中也可以引入快表机构,将近期访问过的段表项放到快表中,这样可以少一次访问,加快地址变换速度。

![分段总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/分段总结.png)

## 段页式管理

（再看




![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/.jpeg)

![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/.png)





