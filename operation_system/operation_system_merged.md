# 第一章

## 操作系统的概念

1. 负责管理协调硬件、软件等计算机资源的工作

2. 为上层的应用程序，用户提供简单易用的服务。

3. 操作系统是系统软件，不是硬件

定义：指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境。它是计算机系统中最基本的系统软件

## 操作系统的功能和目标

![操作系统介绍1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/操作系统介绍1.jpeg)

1. 操作系统作为系统资源的管理者，包括软件，硬件，文件等，需要提供什么功能？

2. 操作系统作为用户与计算机硬件之间的接口，需要为其上层用户、应用程序提供简单易用的服务，需要什么功能？

3. 操作系统作为最接近硬件的层次，需要在纯硬件的基础上实现什么功能？

### 1.作为系统资源的管理者：

进程是一个程序的执行过程，执行前需要将该程序放到内存中，才能被CPU处理。


![系统资源管理1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/系统资源管理1.jpeg)

例子：QQ聊天

1. 在各个文件夹中找到QQ安装的位置：文件管理功能

2. 把该程序相关数据放入内存：存储器管理功能

3. 对应的进程被处理机（CPU）处理： 处理机管理功能

4. 开始和朋友聊天，调用摄像头：设备管理功能

### 2.作为用户与计算机硬件之间的接口

![作为用户与计算机硬件之间的接口](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/作为用户与计算机硬件之间的接口.jpeg)

用户接口：

![用户接口](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/用户接口.jpeg)

联机命令接口：windows中win+R

脱机命令接口实例：windows中 *.bat文件，批处理

程序接口：.dll，只能通过用户程序间接使用。

GUI：图形用户界面Graphical User Interface，用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。Windows，Android，IOS等。

### 3.作为最接近硬件的层次

需要实现对硬件机器的拓展，没有任何软件支持的计算机成为裸机，在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。通常把覆盖了软件的机器称为扩充机器，又称为虚拟机。

## 操作系统的四个特征

并发，共享，虚拟，异步。

**并发**和**共享**是两个最基本的特征，二者互相是存在条件

**并发：** 两个或多个事件在同一时间间隔内发生，这些事件宏观上是同时发生，但微观上是交替发生的。

操作系统的并发性指计算机系统中同时存在着多个运行着的程序。

一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替进行（这些程序微观上是交替执行的，但宏观上就像是同时执行），事实上操作系统就是伴随着“多道程序技术“出现的，因此，操作系统和程序并发是一起诞生的。

**共享：** 资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。

两种资源共享方式：

* 互斥共享：系统中某些资源，虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程访问该资源

* 同时共享：系统中某些资源，允许一个时间段内多个进程同时对他们进行访问。（但在微观上这些进程也可能是交替对资源进行访问：分时共享）

并发性是指计算机系统中同时存在多个运行中的程序。

共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。

**虚拟：** 把一个物理上的实体变为若干个逻辑上的对应物，物理实体是实际存在的，而逻辑上对应物是用户感受到的

虚拟技术中的 *时分复用（虚拟处理器）*，*空分复用（虚拟存储器技术）*

显然如果失去并发性，则一个时间段内系统中只能运行一道程序，就失去了实现虚拟性的意义。因此没有并发性就没有虚拟性。

**异步：** 在多道程序环境下，允许多个程序并发执行，但由于**资源**有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进。

如果失去并发性，系统智能串行地执行各个进程。每个进程的执行只能一贯到底，只有系统拥有并发性，才有可能导致异步性。

## 操作系统的发展和分类

1. 手工操作阶段：打纸带

2. 批处理阶段：单道批处理系统

	引入脱机输入输出技术（磁带），并**监督程序**控制作业的输入，输出————操作系统的雏形
	
3. 批处理阶段：多道批处理

	每次往内存输入多道程序，操作系统正式诞生，并引入了**中断技术**，由操作系统负责管理这些程序的运行，优点：各个程序并发执行，多道程序并发执行，共享计算机资源，资源利用率大幅提升，系统吞吐量增大。缺点：用户相应长，没有人机交互，用户提交自己作业之后就只能等待计算机处理完成，中间不能控制自己作业。

4. 分时操作系统

	计算机以时间片为单位轮流为各个用户/作业服务，各个用户可以通过终端与计算机进行交互。优点：用户请求可以被及时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人存在。缺点：不能优先处理一些紧急任务，操作系统对各个用户/作业完全平等。

5. 实时操作系统

	优点：能够优先响应一些紧急任务。某些紧急任务不需时间片排队
在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且在严格的时间限制内处理完事件。实时操作系统的主要特点是及时性和可靠性。

	实时操作系统分为两种：

	* 硬实时操作系统：必须在绝对严格的规定时间内完成处理

	* 软实时操作系统：能接受偶尔违反时间规定

6. 其他几种操作系统：

	* 网络操作系统：实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。

	* 分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务

	* 个人计算机操作系统

## 操作系统的运行机制和体系结构

什么是**指令**：代码翻译成机器语言指令，指令就是处理器CPU能够识别，执行的最基本命令

### 两种指令

* 特权指令：如内存清零指令，不允许用户程序执行

* 非特权指令：如普通的运算指令

CPU如何判断当前是否可以执行特权指令？规定两种处理器状态

### 两种处理器状态

用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态。0表示用户态，1表示核心态

* 用户态（目态）：此时CPU只能执行非特权指令

* 核心态（管态）：特权指令、非特权指令都可执行

### 两种程序

* 内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态

* 应用程序：为了保证系统能够安全运行，普通应用程序只能执行非特权指令，运行在用户态


### 操作系统的内核

![操作系统的内核](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/操作系统的内核.png)

内核是计算机上配置的底层**软件**，是操作系统最基本、最核心的部分，实现操作系统内核功能的那些程序就是内核程序

![操作系统的内核程序](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/操作系统的内核程序.png)


### 操作系统的体系结构

大内核和微内核

![大内核和微内核](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/大内核和微内核.png)

## 中断和异常

中断机制的诞生：早起电脑只能串行执行程序，系统资源利用率低。为了解决这个问题，发明了操作系统，作为计算机的管理者，引入中断机制，实现了多道程序**并发执行**。本质：发生中断就意味着需要操作系统介入，开展管理工作

### 中断的概念和作用

1. 中断发生时，CPU立即进入**核心态**

2. 中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理

3. 对于不同的中断信号，会进行不同的处理

发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行

问题：**用户态、核心态之间的切换**是怎么实现的？

答：用户态->核心态 是通过中断实现的，并且中断是**唯一**途径。

核心态->用户态 的切换是通过执行一个特权指令，将程序状态字PSW的标志位设置为用户态

### 中断的分类

两种分类方式

![中断的分类1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/中断的分类1.png)

另一种分类方式：

![中断的分类2](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/中断的分类2.png)


### 外中断的处理过程

![外中断的处理过程](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/外中断的处理过程.png)

**Step1:** 执行完每个指令之后,CPU都要检查当前是否有外部中断信号
**Step2:** 如果检测到外部中断信号,则需要保护被中断进程的CPU环境(如程序状态字PSW、程序计数器PC、各种通用寄存器)
**Step3:** 根据中断信号类型转入相应的中断处理程序
**Step4:** 恢复原进程的CPU环境并退出中断,返回原进程继续往下执行

## 系统调用

### 什么是系统调用

操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口，其中，程序接口由一组**系统调用**组成

“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。

应用程序通过系统调用操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源相关的操作（如存储分配，IO操作，文件管理等）都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。


系统调用相关处理涉及到对系统资源的管理，对进程的控制等，这些功能需要一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行

![系统调用](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/系统调用.png)

### 系统调用和库函数

![系统调用与库函数](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter1/系统调用与库函数.png)

当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用。

### 系统调用背后的过程

传递系统调用参数 -> 执行**陷入**指令（用户态） -> 执行系统调用相应服务程序（核心态） -> 返回用户程序

注意：

1. 陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态
	**陷入指令（Traps）**，又叫做自陷指令或访管指令，出现在计算机操作系统中，用于实现在用户态下运行的进程调用操作系统内核程序，即当运行的用户进程或系统实用进程欲请求操作系统内核为其服务时，可以安排执行一条陷入指令**引起一次特殊异常**。

2. 发出系统调用请求是在用户态，而对系统调用的相应处理实在核心态下进行

3. 陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。
# 第二章 第一节 进程和线程

## 进程的定义，组成，组织方式，特征

* 在计算机发展史上，“进程”是为了解决什么问题而被引入的？

* 每个进程由哪些部分组成

* 系统中各个进程之间是如何被组织起来的？

* 相比于程序，进程有哪些特征

## 进程的定义，进程与程序

程序：就是一个指令序列

早期的计算机只支持单道程序，内存：程序的代码放在程序段内，低地址，程序运行过程处理的数据放在数据段内（如变量），高地址。

**多道程序技术：** 引入多道程序技术后：内存中同时放入多道程序，各个程序的代码，运算数据存放的位置不同，操作系统如何找到各个程序的存放位置？


**PCB：** 系统为每个运行的程序配置一个数据结构，称为**进程控制块（PCB）**，用来描述进程的各种信息（如程序代码存放位置）

为了方便操作系统管理，完成各个程序并发执行，引入了进程、进程实体的概念。**PCB、程序段、数据段**三部分构成进程实体（进程映像），一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。

PCB是进程存在的唯一标志！！！

进程的典型定义方式：“动态性”

1. 进程是程序的一次执行过程

2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动

3. 进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位

引入进程实体的概念后，可把进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的，不过一般也不区分。

### PCB的组成：



![PCB组成](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/PCB组成.jpeg)

进程描述信息

进程标识符PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程（类似于身份证号）

寄存器值：当进程切换时需要把进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示当前程序执行到哪一句

## 进程的组织

在一个系统中通常有数十数百个PCB，如何有效组织多个线程

![进程的组织方式](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程的组织方式.jpeg)

### 链接方式

1. 执行指针：指向当前处于运行状态（执行态）的进程

2. 就绪队列指针：指向当前处于就绪态的进程，通常会把优先级高的进程放在队头

3. 阻塞队列指针：指向当前处于阻塞态的进程，很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列

### 索引方式

建立相应功能的索引表

![索引方式](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/索引方式.jpeg)

## 进程的特征

![进程的基本特征](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程的基本特征.jpg)

动态性是进程最基本的特征

**进程是资源分配，接受调度的基本单位**

异步性会导致并发程序执行结果的不确定性

## 进程的状态

进程是运行的一次执行，在这个执行过程中，有时进程正在被CPU处理，有时等待CPU服务，可见进程状态会发生变化，为了方便对各个进程的管理，操作系统需要将进程合理划分为多种状态。

1. **运行状态Running（三种基本状态）：** **占有CPU**，在CPU上运行。

    单核处理机环境下，则每一时刻最多只有一个进程处于运行态，双核则可以同时有两个进程处于运行态。。。

2. **就绪态Ready（三种基本状态）：** 已经具备运行条件，但由于没有空闲CPU，暂时不能运行。

    就绪态下进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。

3. **阻塞态（等待态）Waiting/Blocked（三种基本状态）：** 因等待某一事件暂时不能运行。

    如：等待操作系统分配打印机，读写操作等，由于CPU资源最宝贵，所以处理完别的先再进入就绪态等待

4. **创建态：New** 操作系统需要完成创建进程，操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB

5. **终止态：Terminated** 进程运行结束，操作系统需要完成撤销进程相关的工作，完成将分配给进程的资源回收，撤销PCB等操作

### 进程状态的转换

![进程状态的转换](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程状态的转换.jpeg)

### 进程状态总结

![进程状态总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程状态总结.jpeg)

## 进程控制

进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现进程状态转换功能。

即：实现**进程转换** 

![进程控制1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程控制1.PNG)

**原语**控制：用原语实现进程控制，特点是执行期间不允许中断，必须一气呵成。这种不可以被中断的操作即被称为原子操作。原语采用“关中断指令”和“开中断指令”实现。只允许在核心态下执行的特权指令。

进程控制相关的原语，不论哪种原语，基本思路：

1. 更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）

    * 所有的进程控制原语一定都会修改进程状态标志

    * 剥夺当前运行进程的CPU使用权必然要保存其运行环境

    * 某进程开始运行前必然要恢复其运行环境

2. 将PCB插入合适队列

3. 分配/回收资源

如：

![进程的创建](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程的创建.jpeg)

![进程的终止](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程的终止.jpeg)

![进程的阻塞和唤醒](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程的阻塞和唤醒.jpeg)

阻塞：运行态到阻塞态；唤醒：阻塞态到运行态

阻塞原语唤醒原语必须成对使用

![进程的切换](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程的切换.jpeg)

## 进程通信

![进程通信1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程通信1.jpeg)

进程通信就是进程之间的信息交换，进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。

为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是有时进程之间的通信是必要的。因此需要进程间的安全通信

![进程通信2](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程通信2.jpeg)

### 共享存储

“共享空间”但是两个进程对共享空间的访问必须是**互斥**的，

![共享存储](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/共享存储.jpeg)


共享存储分为两种：

1. 基于**数据结构**的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多、是一种低级通信的方式

2. 基于**存储区**的共享：在内存中划出一块共享存储区，数据形式、存储位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。

### 管道通信

![管道通信](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/管道通信.jpeg)

管道是指用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的**缓冲区**。

1. 管道只能采用半双工通信，某一时间段内只能实现单向传输，如果要实现双向同时通信，需要设置两个管道。

2. 各个进程需要互斥地访问管道。

3. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走，当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。

4. 如果没写满，就不允许读，如果没读空，就不允许写。

5. 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。

### 消息传递

进程之间的数据交换以格式化信息（Message）为单位，进程通过操作系统的“发送消息/接收消息“两个原语进行数据交换。

![消息传递](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/消息传递.jpeg)

### 总结

![进程通信总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程通信总结.jpeg)

## 线程

### 线程的概念

什么是线程：

在进程中，进程是程序的一次执行，传统的进程是程序执行流的最小单位，但这些功能不可能是由同一个程序顺序处理就能实现的。引入线程来增加并发度，引入线程后线程成为了**程序执行流**的最小单位。

线程是一个基本的**CPU执行单元**，也是程序执行流的最小单位。引入线程后不仅是各进程之间可以并发，进程中的线程之间也可以并发，进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务。

引入线程后，进程只作为除cpu之外的系统资源的分配单元（如打印机/内存地址空间都是分配给进程的）。

引入线程后的变化

![线程和进程1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/线程和进程1.png)

### 线程的属性

* 线程是处理机调度的基本单位，多CPU计算机中，各个线程可以占用不同的CPU
  
* 每个线程都有一个线程ID，**线程控制块（TCB）**

* 线程也有就绪、阻塞、运行三种基本状态

* 线程几乎**不拥有系统资源**，他们的系统来自于所在的进程，同一进程的不同线程之间共享进程的资源，由于共享内存地址空间，同一进程中的线程间的通信甚至无需系统干预

* 同一进程中的线程切换，不会引起进程切换；不同进程中的线程切换，会引起进程切换：切换同进程内的线程，系统开销很小，切换进程，系统开销较大。

### 线程的实现方式

1. 用户级线程ULT（user-level-thread）

	用户级线程通过线程库实现，所有的线程管理都由应用程序负责（包括线程切换）。用户级线程中，线程切换在用户态下即可完成，无需操作系统干预。在用户看来有多个线程，但是在操作系统内核看来，并意识不到线程的存在，即用户级线程对用户不透明，对操作系统透明。

![用户级线程](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/用户级线程.png)

2. 内核级线程KLT（kernel-level-thread）

	内核级线程管理工作由操作系统内核完成。 线程调度、切换等工作都由内核负责，因此内核级线程切换必然需要在核心态下才能完成。

![内核级线程](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/内核级线程.png)

在同时支持用户级线程和内核级线程的操作系统中，采用二者组合的方式，将n个用户映射到m个内核级线程上。（n >=m )

操作系统只能看得见内核级线程，因此只能内核级线程才是处理机分配的单位。


### 多线程模型

在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型问题”。
注：内核级：物理结构，用户级：逻辑结构

* 多对一模型

	多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程。

	优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。

	缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上运行

* 一对一模型：

	一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程。

	优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可以在多核处理机上并行执行

	缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

* 多对多模型

	n个用户级线程映射到m个内核级线程（n>=m)，每个用户进程对应m个内核级线程

	克服了多对一模型并发度不高的缺点，也克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。





















# 第二章 第二节 处理机调度

## 调度，处理机调度的概念

有一堆任务要处理，但是资源有限，这些事情没办法同时处理，就需要确定某种规则来决定**处理这些任务的顺序**，这就是调度

在多道程序系统中，进程的数量往往多于处理机的个数，这样不可能同时并行地处理各个进程，处理机调度就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行

## 调度的三个层次：

## 高级调度。

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业**调入内存**的顺序。

高级调度（作业调度）：按照一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使他们获得竞争处理机的权利。

高级调度是外存与内存之间的调度，每个作业只调入一次，调出一次。掉入作业时会建立相应的pcb，调出时撤销pcb。高级调度主要是指掉入的问题，因为只有掉入时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

## 中级调度

引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待，等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是为了提高内存利用率和系统吞吐量。
暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存，pcb中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的pcb来保持对各个进程的管理、监控，被挂起的进程pcb会被放到挂起队列中
 

中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。
一个进程可能被多次调入调出内存，因此中级调度发生的频率要比高级调度更高。

进程的挂起态和七状态模型

![七状态模型](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/七状态模型.png)

### 低级调度

低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。

进程调度的频率很高，一般几十毫秒一次。

### 三层调度的联系、对比

![三层调度](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/三层调度.png)

## 进程调度的时机

进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机

![进程调度的时机](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程调度的时机.png)

**临界资源：** 一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源。

**内核程序临界区**一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的pcb组成）。

## 进程调度的方式

* 非剥夺调度方式/非抢占方式：只允许进程**主动放弃处理机**，在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。

	实现简单，系统开销小但是无法及时处理紧急任务，适合早起的批处理系统

* 剥夺调度方式/抢占方式：当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程

	可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能（通过时钟中断），适合于分时操作系统，实时操作系统。

## 进程的切换与过程

“狭义的进程调度与进程切换”的区别:

狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程, 也可能是另一个进程，后一种情况就需要进程切换)

进程切换是指一个进程让出处理机,由另一个进程占用处理机的过程。

广义的进程调度包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了:
1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复
(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息,这些信息一般保存在进程控制块)
注意:进程切换是有代价的,因此如果过于频繁的进行进程调度、切换,必然会使整个系统的效率降低, 使系统大部分时间都花在了进程切换上,而真正用于执行进程的时间减少


## 调度算法的评价指标

### CPU利用率

CPU忙碌的时间占比总时间的比例

利用率=忙碌时间/总时间

### 系统吞吐量

单位时间内完成作业的数量

系统吞吐量=总共完成了多少道作业/总共花了多少时间

### 周转时间

指从昨夜被提交到系统开始，到作业完成为止的这段时间间隔。

包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间，进程在就绪队列上等待进程调度（低级调度）的时间，进程在cpu上执行的时间，进程等待io操作完成的时间。后三项在一个作业的整个处理过程中可能发生多次

（作业的）周转时间 = 作业完成时间 - 作业提交时间

平均周转时间 = 各作业周转时间之和/作业数

### 带权周转

![带权周转](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/带权周转.png)

对于周转时间相同的两个作业,实际运行时间长的作业在相同时间内被服务的时间更多, 带权周转时间更小,用户满意度更高

对于实际运行时间相同的两个作业,周转时间短的带权周转时间更小,用户满意度更高

平均带权周转时间=各作业带权周转时间之和/作业数

### 等待时间

计算机希望自己的作业尽可能少的等待处理机。

等待时间指的是进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。

对于进程来说，等待时间就是指进程建立之后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。

对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。

一个作业总共需要被CPU服务多久，被I/O设备服务多久一般也是确定不变的，因此调度算法其实只会影响作业/进程的等待时间，当然，与前面指标相似，也有平均等待时间来评价整体性能。

### 响应时间

从用户提交请求到首次产生相应所用的时间。

### 总结

![调度算法的评价和指标](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/调度算法的评价和指标.png)

## 调度算法1

先来先服务（FCFS），短作业优先（SJF），高响应比优先（HRRN）

对于每个算法，考虑：

* 算法思想，算法规则

* 适用于作业调度还是进程调度

* 抢占式，非抢占式

* 优缺点

* 是否会导致**饥饿**：某进程/作业长时间得不到服务

### 先来先服务First Come First Serve

* 思想，规则：公平，排队，先来先得

* 用于作业/进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列，用于进程调度时，考虑的是哪个进程先到达就绪队列

* 非抢占

* 优点：公平、算法实现简单

* 缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好，即，FCFS算法对长作业有利，对短作业不利

* 是否会导致饥饿：不会

<!--* 例题，计算：

<!--![FCFS例题](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/FCFS例题.png)-->

### 短作业优先Shortest Job First

* 思想，规则：追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间

* 算法规则：最短的作业/进程优先得到服务（要求服务时间最短）

* 用于作业/进程调度：既可以用于作业调度，又可以进程调度，用于进程调度时称为短进程优先（SPF，shortest process first）

* SJF和SPF都是非抢占式算法，但是也有抢占式版本：最短剩余时间优先算法（SRTN，shortest remaining time next）

* 优点：平均等待时间，平均周转时间最短

* 缺点：不公平，对短作业有利，对长作业有力，可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定做到真正的短作业优先。

* 是否会导致饥饿。会，如果短作业源源不断地来，会使得长作业/进程长时间得不到服务，产生饥饿现象

<!--* 例题-->

<!--![SJF例题](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/SJF例题.png)-->

<!--![SRTN例题1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/SRTN例题1.png)-->

<!--![SRTN例题2](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/SRTN例题2.png)-->

### 高响应比优先Highest Response Ratio Next

* 思想：综合考虑作业/进程的等待时间和要求服务的时间

* 算法规则：每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务

	响应比=（等待时间+要求服务时间）/要求服务时间

* 用于作业/进程调度：既可以用于作业调度，也可以用于进程调度

* 是否可以抢占：非抢占式算法

* 优点：综合考虑了**等待时间**和**运行时间**（要求服务时间），等待时间相同时，要求服务时间短的优先（SJF的优点），要求服务时间相同时，等待时间长的优先（FCFS的优点），对于长作业来说，等待时间长了响应比也会变大，避免了长作业饥饿的问题。


* 是否会导致饥饿：不会
   
### 三种算法总结

这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标,但是不区分任务的**紧急程度**,因此对于用户来说,**交互性**很糟糕。因此这三种算法一般适合用于早期的批处理系统,当然,FCFS算法也常结合其他的算法使用,在现在也扮演着很重要的角色。

## 调度算法2

时间片轮转调度算法（RR），优先级调度，多级反馈队列调度算法

对于每个算法，考虑：

* 算法思想，算法规则

* 适用于作业调度还是进程调度

* 抢占式，非抢占式

* 优缺点

* 是否会导致饥饿：某进程/作业长时间得不到服务

### 时间片轮转Round-Robin

* 思想：公平地，轮流地为各个进程服务，让每一个进程在一定时间间隔内都可以得到响应

* 规则：按照各进程到达就绪队列的顺序，**轮流让各个进程执行一个时间片**（如100ms），若进程未在一个时间片内执行完，则剥夺处理机，将进程放到就绪队列队尾重新排队。每次都选择排在就绪队列队头的进程

	如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务算法，并且会增大进程响应时间，因此时间片不能太大

	时间片太小，进程切换过于频繁，系统消耗大量时间来处理进程切换。

	一般来说设计时间片让切换进程的开销占比不超过1%。

* 用于作业/进程：用于进程调度，因为只有作业放入内存建立了相应的进程后，才能被分配处理机时间片

* 是否是抢占式：**抢占式**，由时钟装置发出时钟中断来通知CPU时间片已到

* 优点：**公平**，响应快，适用于分时操作系统

* 缺点：由于高频率的进程切换，因此会有一定开销；不能区分任务的紧急程度

* 是否会导致饥饿？不会

### 优先级调度算法

* 思想：考虑任务的紧急程度

* 规则：每个作业/进程都有各自的优先级，调度时选择优先级最高的作业/进程

* 用于作业/进程：既可以用于作业调度，也可以用于进程调度，甚至也可以用于I/O调度

* 是否可以抢占：抢占式和非抢占式都有

* 根据优先级是否可变，可分为静态优先级和动态优先级

	通常系统优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I/O型进程（I/O繁忙型进程），因为IO设备可以和cpu并行工作，先让io繁忙型进程进程运行可以让I/O设备尽早投入工作，资源利用率，系统吞吐量提升

* 优点：用优先级区分紧急程度，重要程度，适用于实时操作系统，可灵活地调整对各种作业/进程的偏好程度

* 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿

* 会导致饥饿

### 多级反馈队列调度算法

* 思想：各种调度算法的折衷

* 规则：

	1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大

	2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾

	3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片

* 用于进程/作业？ 用于进程

* 是否可以抢占：抢占式算法，在k级队列的进程运行过程中，若更上级的队列（1-k-1级）中进入了一个新进程，这个新进程会抢占处理机

* 对各类进程相对公平（FCFS的优点）；每个新到达的进程都可以很快得到响应（RR的优点）；短进程只用较少的时间就可以完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，如CPU密集型进程、I/O密集型进程

* 会导致饥饿

### 总结

注:比起早期的批处理操作系统来说,由于计算机造价大幅降低,因此之后出现的交互式操作系统(包括 分时操作系统、实时操作系统等)更注重系统的**响应时间、公平性、平衡性**等指标。而这几种算法恰好也能较好地满足**交互式**系统的需求。因此这三种算法适合用于交互式系统。(比如UNX使用的就是多级反馈 队列调度算法)























# 第二章 第三节 进程同步

## 进程同步

回顾：进程有异步性的特征，各并发执行的进程以各自独立，不可预知的速度向前推进。因此需要进程进程同步解决这种**异步问题**。有的进程之间需要**相互配合**地完成工作，各进程的工作推进需要遵循一定的先后顺序

“同步”也可称为直接制约关系

## 进程互斥

各个并发执行的进程不可避免地需要共享一些系统资源，资源共享分为

* 互斥共享：系统中的某些资源虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程访问该资源。
* 同时共享：系统中某些资源，允许一个时间段内由多个进程“同时”对他们进行访问。

把一个时间段内只允许一个进程使用的资源称为**临界资源**，对临界资源的访问必须**互斥**地执行，即同一时间段内只能允许一个进程访问该资源，对临界资源的互斥访问分为四个部分：

![临界资源访问](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/临界资源访问.png)

注意:
* **进入区** 负责检查是否可进入临界区,若可进入,则应设置正在问临界资源的标志(可理解为 **“上锁”**),以阻止其他进程同时进入临界区

* **临界区**是访问临界资源的那段代码，是进程中访问临界资源的代码段。临界区也可称为“临界段”。

* **退出区** 负责解除正在访问临界资源的标志(可理解为“解锁”)，进入区和退出区是负责实现互斥的代码段。 
* 退出区可以做一些其他处理

为了实现对临界资源的**互斥访问**，同时保证整体性能，需要遵循以下**原则**：

1. 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区


2. 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待

3. 有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）

4. 让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待

### 总结

![进程互斥总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程互斥总结.jpeg)

## 进程互斥的软件实现

单标志法，双标志先检查，双标志后检查，Peterson算法。

    每个方法考虑：
    1. 各个算法的思想、原理
    2. 结合“实现互斥的四个逻辑部分”，理解各个算法在进入区，退出区都做了什么
    3. 结合“实现互斥的四个原则”，分析各个算法的缺陷

### 单标志法

思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每一个进程进入临界区的权限只能被另一个进程赋予。

![单标志法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/单标志法.png)

这种必须“轮流访问”带来的问题是,如果此时允许进入临界区的进程是PO,而PO一直不访问临界 区,那么虽然此时临界区空闲,但是并不允许P1访问。**违背了空闲让进原则。**

### 双标志先检查法

思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如flag[0]=true标识0号进程现在想要进入临界区。每个进程进入临界区之前先检查当前有没有别的进程想要进入临界区，如果没有，则把自己对应的标志flag[i]设置为true，之后开始访问临界区。

![双标志先检查法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/双标志先检查法.png)

有可能多个进程**同时访问到临界区**：进入区的“检查”和“上锁”两个处理不是一气呵成的，“检查”后，“上锁”前可能发生进程切换。**违反“忙则等待”原则**

### 双标志后检查法

改进双标志先检查法，前一个算法的问题时先检查后上锁，但是这两个操作没法一气呵成，因此可能两个进程同时进入临界区，所以可以先上锁后检查

![双标志后检查法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/双标志后检查法.png)

但是违反了空闲让进和有限等待，两个进程都想进入临界区但是互不相让，可能会产生饥饿现象。

### Peterson算法

双标志后检查算法中，两个算法互相争抢，Peterson算法中，如果双方都争着想进入临界区，那可以让进程主动让对方先使用临界区

![peterson算法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/peterson算法.png)

遵循了空闲让进，忙则等待，有限等待，但是没有遵循**让权等待**

## 进程互斥的硬件实现

中断屏蔽，TestAndSet（TS指令，或TSL指令），Swap指令（XCHG指令）

### 中断屏蔽

利用**开中断、关中断指令**实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此不可能发生两个同时访问临界区的情况）

优点：简单高效

缺点：不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程（因为开中断关中断指令只能运行在内核态，不能让用户随意应用）

### TestAndSet指令

用硬件实现的，执行的过程中不允许被中断，只能一气呵成，

![testandset](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/testandset.png)

若刚开始lock是false,则TSL返回的old值为 false, while循环条件不满足,直接跳过循环,进入临界区。若刚开始lock是true,则执行TLS后old返回的值为true, while循环条件满足,会一直循环,直到当前访问临界区的进程在退出区进行“解锁”。

相比软件实现方法,TSL指令把“上锁”和“检査”操作用硬件的方式变成了一气呵成的原子操作。 

优点:实现简单,无需像软件实现方法那样严格检查是否会有逻辑漏洞;适用于多处理机环境

缺点：不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”

### Swap指令
有的地方也叫 Exchange指令,或简称XCHG指令。

Swap指令是用硬件实现的,执行的过程不允许被中断,只能一气呵成。以下是用C语言描述的逻辑

![Swap指令](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/Swap指令.png)

逻辑上来看Swap和TSL并无太大区别,都是先记录下此时临界区是否已经被上锁(记录在old变量上),再将上锁标记lock设置为true,最后检查old,如果old为false则说明之前没有别的进程对临界区上锁,则可跳出循环,进入临界区。

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境

缺点：不满足“让权等待”，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”

### 总结

![进程互斥的硬件实现总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/进程互斥的硬件实现总结.png)

## 信号量机制

**整形信号量，记录型信号量**	

回顾：以上解决方案均无法实现**让权等待**，引入信号量机制。

用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便地实现了进程互斥、进程同步。

信号量其实就是一个**变量**（可以是一个整数，可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量。比如系统中只有一台打印机，就可以设置一个初始值为1的信号量

原语是一种特殊的程序段，其执行不能被中断，只能一气呵成。原语是由开中断/关中断指令实现的，软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”。因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题

一对原语：wait(S)和signal(S)，也被写为**P(S)**和**V(S)**

wait(S)和signal(S)是自己写的函数，S就是信号量

### 整形信号量

整形信号量，用来表示系统中某种资源的数量，如系统中有一台计算机 S为1

![整形信号量](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/整形信号量.png)

对信号量的操作只有三种：初始化，P操作和V操作

检查和上锁作为原语一气呵成，避免并发、异步导致的问题

问题：不满足让权等待原则，会发生忙等

### 记录型信号量

用记录型数据结构表示的信号量

![记录型信号量](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/记录型信号量.png)

释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态

在考研题目中wait(S)、 signal(S)也可以记为P(S)、V(S),这对原语可用于实现系统资源的“申请”和“释放”。

S.value的初值表示系统中某种资源的数目。

对信号量S的一次P操作意味着进程请求一个单位的**该类资源**,因此需要执行S.value--,表示资源数减1,当S.value<0时表示该类资源已分配完毕,因此进程应调 用block原语进行自我阻塞(当前运行的进程从运行态→阻塞态),主动放弃处理机,并插入该类资源的等 待队列S.L中。可见,该机制遵循了“让权等待”原则, 不会出现“忙等”现象。

对信号量S的一次V操作意味着进程**释放**一个单位的该类资源,因此需要执行S.value++,表示资源数加1, 若加1后仍是S.value<=0,表示依然有进程在等待该类资源,因此应调用wakeup原语唤醒等待队列中的第个进程(被唤醒进程从阻塞态￫就绪态)。

### 信号量机制实现互斥

使用临界资源之前要加锁，使用临界资源后要解锁。对不同临界资源的使用需要设置不同的互斥信号量。P操作V操作必须成对使用

### 信号量机制实现同步

用信号量实现进程同步，“让各个并发进程有序地推进”:
1. 分析什么地方需要实现“同步关系”,即必须保证“一前一后”执行的两个操作(或两句代码)
2. 设置同步信号量S,初始为0
3. 在“前操作”之后执行V(S)
4. 在“后操作”之前执行P(S)

若先执行到P(S)操作,由于S=0,S--后S=-1,表示此时没有可用资源,因此P操作中会执行 block原语,主动请求阻塞。之后当执行完代码2,继而执行V(S)操作,S++,使S变回0, 由于此时有进程在该信号量对应的阻塞队列中,因此会在V操作中执行 wakeup原语,唤醒P2进程。这样P2就可以继续
执行代码4了。

### 信号量机制实现前驱关系

![信号量机制实现前驱关系](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/信号量机制实现前驱关系.png)

### 信号量机制实现各种操作总结

![信号量机制实现各种操作总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/信号量机制实现各种操作总结.png)

## 生产者消费者问题

系统中有一组生产者进程和一组消费者进程，生产者每次生产一个“产品”放入缓冲区，消费者每次从缓冲区取出一个“产品”并使用，产品指某种数据。

生产者、消费者共享一个初始为空，大小为n的缓冲区。

只有缓冲区不满时，生产者才能把产品放入缓冲区，否则必须等待。

只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。缓冲区时临界资源，各进程必须互斥访问。

可以用信号量机制实现生产者、消费者进程的这些功能

死锁问题


## 多生产者多消费者 


多生产者，多消费者共享缓冲区 


### 吸烟者问题

### 读者-写者问题

### 哲学家进餐问题


## 管程

信号量机制的问题：编写程序困难、易出错

为了再写程序时不需要再关注复杂的pv操作，引入管程

### 管程的定义和基本特征

管程是一个特殊的软件模块，由这些部分组成

1. 局部于管程的共享数据结构说明

2. 对该数据结构进行操作的一组过程

3. 对局部于管程的共享数据设置初始值的语句

4. 管程有一个名字

管程的基本特征：

1. 局部于管程的数据只能被局部于管程的过程所访问

2. 一个进程只有通过调用管程内过程才能进入管程访问共享数据

3. 每次仅允许一个进程在管程内执行某个内部过程

![用管程解决生产者消费者问题](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/用管程解决生产者消费者问题.png)

由编译器负责实现各进程互斥地进入管程中的过程

### 实现互斥和同步

1. 需要在管程中定义共享数据（如缓冲区）

2. 需要在管程中定义用于访问这些共享数据的“入口”————其实就是一些函数

![管程](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/管程.png)

### 管程总结

![管程总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/管程总结.png)

# 第二章 第四节 死锁

## 死锁的概念

### 死锁的概念

在并发环境下，各个进程因为竞争资源而造成的一种**互相等待**对方手里的资源，导致各个进程**都阻塞**，都无法向前推进的现象，就是死锁。发生死锁后若无外力干涉，这些进程都将无法推进。

### 死锁，饥饿，死循环

死锁：“死锁概念”，至少是两个或以上的进程才能发生死锁，一定是在阻塞态

饥饿：可以是只有一个进程发生饥饿，长时间得不到资源，可能是在阻塞态，可能是在就绪态

死循环：程序执行过程中一直跳不出某个循环的现象。

### 死锁产生的必要条件

产生死锁必须同时满足以下四个条件：

1. 互斥条件：只有必须对互斥使用的资源争抢才会导致死锁

2. 不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放

3. 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放

4. 循环等待条件：存在一种进程资源的**循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求。

### 什么时候发生死锁：

1. 对系统资源的竟争。各进程对**不可剥夺**的资源(如打印机)的竞争可能引起死锁,对**可剥夺**的资源(CPU)的竟争是**不会**引起死锁的
2. 进程推进顺序非法。**请求和释放资源的顺序不当**,也同样会导致死锁。例如,并发执行的进程P1、P2分别申请并占有了资源R1、R2,之后进程P1又紧接着申请资源R2,而进程P2又申请资源R1, 两者会因为申请的资源被对方占有而阻塞,从而发生死锁
3. **信号量的使用不当**也会造成死锁。如生产者-消费者问题中,如果实现互斥的P操作在实现同步的P操作之前,就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)
   
总之,对不可剥夺资源的不合理分配,可能导致死锁。

### 死锁的处理策略

1. 预防死锁：破坏死锁产生的四个必要条件中的一个或几个

2. 避免死锁，用某种方法防止系统进入不安全状态

3. 死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁


### 预防死锁

**破坏互斥条件**

把只能互斥使用的资源改造为允许共享使用，比如SPOOLing技术。spooling队列

缺点：并不是所有的资源都可以改造成可共享使用的资源，而且为了系统安全，很多地方还必须保持互斥性

**破坏不剥夺条件**

不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放

1. 方案一：当某个进程请求新的资源而得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请，也就是说，即使某些资源尚未使用完，也需要主动释放，这样就破坏了不可剥夺事件。

2. 方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺，这种方式一般需要考虑各进程的优先级，比如剥夺调度方式，就是将处理机的资源强行剥夺给优先级更高的进程使用

缺点：

* 实现起来比较复杂。

* 释放已经获得的资源可能会导致前一阶段的工作失效，因此本方法一般只适用于易保存和易恢复状态的资源，如CPU。

* 反复申请和释放资源会增加系统开销，降低系统吞吐量。

* 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请，如果一直发生这样的情况：进程饥饿。

**破坏请求和保持条件**

请求和保持条件：进程已经保持了至少一个资源，但是又提出了新的资源请求，而该资源又被其他进程所占有，此时请求进程被阻塞，但又对自己已有的资源保持不放

可以采用**静态分配方法**：即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让他投入运行，一旦投入运行后，这些资源就一直归他所有，该进程就不会再请求别的任何资源了。

该策略实现起来简单，也有明显的缺点：

有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。


**破坏循环等待条件**

循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被下一个进程所请求

可采用**顺序资源分配法**：首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（编号相同的资源）一次申请完。

原理：一个进程只有已经占有小编号的资源时，才有资格申请更大编号的资源。按此规则,已持有大编号资源的进程不可能逆向地回来申请小编号的资源,从而就不会产生循环等待的现象。

![破坏循环等待条件](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/破坏循环等待条件.png)


缺点：

* 不方便增加新的设备，因为可能需要重新分配所有编号

* 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费

* 必须按规定次序申请资源，用户编程麻烦


### 避免死锁

1. 安全序列

安全序列指如果系统按照这个序列完成分配资源，每个进程都能顺利完成，只要能找出一个安全序列，系统就是安全状态。

如果分配资源后找不到任何一个安全序列，系统就进入了不安全状态，这就意味着之后可能所有进程都无法顺利执行下去，当然如果有进程提前归还了一些资源，那系统也可能重新回到安全状态。

可以在资源分配之前就先预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求，这也是银行家算法的核心思想


2. 银行家算法

在资源分配之前就先预先判断这次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

![银行家算法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/银行家算法.png)

![银行家算法2](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/银行家算法2.png)


## 死锁的检测和解除

1. 死锁的检测算法

检测系统状态，以确定系统是否发生了死锁

2. 死锁的解除算法

当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来

### 死锁的检测

为了能对系统是否发生了死锁进行检测，必须：

1. 用某种数据结构来保存资源的请求和分配信息

2. 提供一种算法，利用上述信息来检测系统是否已进入死锁状态

![死锁的检测1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/死锁的检测1.png)

![死锁的检测2](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/死锁的检测2.png)

![死锁的检测3](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter2/死锁的检测3.png)

### 死锁的解除

一旦检测出死锁的发生，就应该立即解除死锁，并不是系统中所有的进程都是死锁状态，用死锁检测算法简化资源分配图后，还连着边的那些进程就是死锁进程

解除死锁的主要方法：

1. 资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。

2. 撤销进程法：强制撤销部分甚至全部 死锁的进程。简单但是代价太大。

3. 进程回退法：让一个或多个死锁进程退回到足以避免死锁的地步，这就要求系统要记录进程的历史信息，设置还原点，算法麻烦。

如何决定对谁执行操作：

进程优先级，已执行的时间，还要多久能完成，进程已经使用了多少资源，进程是交互式还是批处理式
























# 第三章 第一节 内存

## 内存概念

内存是用于存放数据的硬件，程序执行前需要先放到内存中才能被CPU处理

于是：在多道程序环境下，系统中多个进程并发执行，多个程序的数据需要同时放到内存中，如何区分各个程序的数据需要放到什么地方？

方法：给内存的存储单元变地址，内存地址从0开始，每个地址对应一个存储单元

如果计算机”按字节编址“，则每个存储单元大小为一字节，1B，即8个二进制位

如果”按字编址“，每个存储单元大小为1个字，字长十六位的计算机中每个字的大小为16个二进制位。


![内存介绍1](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/内存介绍1.jpeg)

## 进程的运行原理：指令

![指令](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/指令.jpeg)

相对地址=逻辑地址，绝对地址=物理地址


## 从写程序到运行

![从写程序到运行](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/从写程序到运行.jpeg)

装入模块中的地址指的是“相对地址”，但是装入模块装入内存时，需要对指令中的地址进行处理。装入的三种方式（由三种不同的方法完成逻辑地址到物理地址的转换）：

1. 绝对装入 
2. 静态重定位
3. 动态重定位


### 绝对装入

在编译时，如果知道程序将放入内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。

绝对装入只适用于单道程序环境。程序中使用的绝对地址可以在编译或汇编时给出，也可由程序猿直接赋予。

### 静态重定位

又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址。

静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存就不能再移动，也不能再申请内存空间。

### 动态重定位

动态重定位又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行，这种方式需要一个重定位寄存器的支持。

采用动态重定位时允许程序在内存中发生移动。并且可以将程序分配到不连续的存储区中，在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存。


## 内存管理

* 操作系统负责内存的分配和回收

* 操作系统需要提供某种技术从逻辑上对内存空间进行扩充（虚拟内存）

* 操作系统需要提供地址转换功能，负责程序的逻辑地址和物理地址的转换

* 操作系统提供内存保护功能，保证各个进程在各自存储空间内运行，互不干扰

	内存保护两种方法：

	1. 在cpu中设置一堆上下限寄存器，存放进程的上下限地址。进程的指令要访问某个地址时，cpu检查是否越界

	2. 重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）进行越界检查，分别存放起始地址和长度

## 内存空间的扩充：覆盖和交换

![覆盖和交换](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/覆盖和交换.jpeg)

### 覆盖技术

思想：把程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时放入内存。需要常驻内存的段放在固定区，不常用的段放在覆盖区。内存中分为一个固定区和多个覆盖区。

![覆盖技术](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/覆盖技术.jpeg)

### 交换技术

内存空间紧张时，系统将内存中某些进程暂时换出到外存，把外存中某些已具备运行条件的进程换入到内存


暂时换出到外存等待的进程状态为挂起状态suspend

挂起状态可进一步细分为就绪挂起和阻塞挂起

问题：

1. 应该在外存的什么位置保存被换出的进程？

2. 什么时候交换？

3. 换出哪些进程？

（补全文字）

![交换技术](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/交换技术.jpeg)

1. 具有兑换功能的操作系统中，通常把磁盘空间分为文件区和对换区

2. 

3. 

但是pcb会常驻内存，不会被换出外存

## 连续分配式管理

连续分配：为用户进程分配的必须是一个连续的内存空间

### 单一连续分配

![单一连续分配](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/单一连续分配.jpeg)


### 固定分区分配

将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一个作业。
有两种策略：
分区大小相等/分区大小不等。

分区大小相等：缺乏灵活性，但是适合用于用一台计算机控制多个相同对象的场合。

分区大小不等：增加灵活性，满足不同大小的进程需求。

如何记录空闲/分配情况：分区说明表，每个表项包括对应分区的大小，起始地址，状态。


优点：简单，无外部碎片

缺点：内部碎片；万一某个用户程序太大，分区不能满足需求


### 动态分区分配

进程装入内存时，根据进程的大小动态建立分区。

1. 操作系统要用什么样的数据结构记录内存的使用情况？

	空闲分区表：分区区号，分区大小，起始地址，分区状态

	空闲分区链：双向链表。每个分区的起始和末尾部分分别设置前向指针和后向指针。起始部分处还可以记录分区大小等信息

2. 当很多空闲分区都能满足需求时，应该选择哪个分区进行分配

	动态分区分配算法，

3. 动态分区的回收操作

	合并相邻的空闲分区，新增表项。。。


动态分区分配没有内部碎片，但是有外部碎片

内部碎片：分配给某进程的内存区域，有某些部分没有用上

外部碎片：内存中某些空闲分区由于太小而难以利用。“紧凑技术”


### 动态分区分配算法

![动态分区分配算法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/动态分区分配算法.jpeg)

1. 首次适应算法

	每次都从低地址开始查找，找到第一个能满足大小的空闲分区。

	空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区链（空闲分区表）

2. 最佳适应算法

	优先使用更小的空闲区。空闲分区按容量递增次序链接，每次分配内存时顺序查找空闲分区链（表），找到能满足大小要求的第一个分区

	缺点：留下很多难以利用的碎片，产生很多外部碎片

3. 最坏适应算法

	又称最大适应算法：为了解决分配留下太多难以利用的小碎片，可以每次都优先使用最大的连续空闲区。

	缺点：每次都利用较大的空闲区，如果后续有大进程到达就没有内存分区可用

4. 临近适应算法

	每次分配查找时都从上次超找结束的位置开始检索，（空闲分区排成循环链表）


比较：

![动态分区分配算法比较](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/动态分区分配算法比较.jpeg)



## 非连续分配方式：基本分页存储管理

考虑支持多道程序的两种连续分配方式：
固定分区分配，动态分区分配都有缺点。

如果允许将一个进程分散地放入许多不相邻分区，则可以充分利用内存。即“非连续分配方式”，或称为“离散分配方式”。

**基本分页存储管理**，基本分段存储管理，段页式存储管理。

### 基本分页存储管理：

把内存分为一个个相等的小分区，再按照分区大小把进程分成一个个小部分。

内存空间分为的分区称为页框（页帧，内存块，物理块），编号从0开始。页框也不宜过大，否则内部碎片太大。操作系统以页框为单位给各个进程分配空间。

### 如何实现地址转换（物理地址和逻辑地址之间）

1. 页号：除法取整数部分

2. 页内偏移量

3. 页面在内存中的起始位置

4. 物理地址 = 页面地址 + 页内偏移量


### 页表

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表

![页表](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/页表.jpeg)

每个页表项的长度是相同的，页号是隐含的。（说不明白就不要说）

## 基本地址变换机构

用于实现逻辑地址到物理地址转换的一组硬件结构。可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。

进程未执行时，页表的起始地址和页表长度放在进程控制模块PCB中，进程被调度时，操作系统内核会把它们放到页表寄存器中。

![基本地址变换机构](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/基本地址变换机构.png)

 
![基本地址变换机构总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/基本地址变换机构总结.png)

## 具有快##表的地址变换结构

### 局部性原理：

时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很可能再次执行，如果某个数据被访问后，不久后这个数据很可能会被再次访问

空间局部性：一旦程序访问了某个存储单元，不久之后其附近的存储单元可能也被访问（因为很多数据在内存之中都是连续存放的） 

因此在之前的基本地址变换机构中，可能连续很多次查询同一个页表项

### 快表TLB：

又称**联想寄存器**，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此相对，**内存**中的页表称为慢表。

![快表TLB](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/快表TLB.jpeg)


快表中存放的是页表的一部分副本，若快表命中就不需要再访问内存。

### 引入快表之后，地址的变换过程

![引入快表之后地址的变换过程](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/引入快表之后地址的变换过程.jpeg)

### 总结

![快表总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/快表总结.jpeg)

## 两级页表

### 单级页表的问题

![单级页表的问题](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/单级页表的问题.jpeg)

根据局部性原理，很多时候进程在一段时间内只需要访问某几个页面就可以正常运行了，没有必要让整个页表都常驻内存。

问题：

1. 页表必须连续存放,因此当页表很大时,需要占用很多个连续的页框。 
2. 没有必要让整个页表常驻内存,因为进程在一段时间内可能只需要访问某几个特定的页面。

### 如何解决单级页表的问题1 

可将长长的页表进行分组,使每个内存块刚好可以放入一个分组。

另外,要为离散分配的页表再建立一张页表,称为页目录表,或称外层页表,或称顶层页表。

**如何实现地址变换**

1. 按照地址结构将逻辑地址拆分成三部分
2. 从PCB中读出页目录表始址,再根据一级页号査页日 录表,找到下一级页表在内存中的存放位置
3. 根据二级页号査表,找到最终想访问的内存块号
4. 结合页内偏移量得到物理地址

### 如何解决单级页表的问题2

可以在需要访问页面时才把页面调入内存(虚拟存储技术)。可以 在页表项中增加一个标志位,用于表示该页面是否已经调入内存。

若想访问的页面不在内存中,则 产生缺页中断(内中断),然后 将目标页面从外存调入内存

### 总结

![两级页表总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/两级页表总结.jpeg)

## 基本分段存储管理

**分段**和分页的区别就是离散分配地址空间的基本单位不同。

段的大小不一，因为是**逻辑**上的划分

段表：段的映射表

![分段分页](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/分段分页.jpeg)

而且：
分段比分页更容易实现信息的共享和保护

![分段分页2](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/分段分页2.jpeg)

页是信息的物理单位。分页的主要目的是为了实现离散分配,提高内存利用率。分页仅仅是系统管 理上的需要,完全是系统行为,对用户是不可见的。
段是信息的逻辑单位。分页的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻 辑模块的信息。分段对用户是可见的,用户编程时需要显式地给出段名。 页的大小固定且由系统决定。段的长度却不固定,决定于用户编写的程序。 分页的用户进程地址空间是一维的,程序员只需给出一个记忆符即可表示一个地址
分段的用户进程地址空间是二维的,程序员在标识一个地址时,既要给出段名,也要给出段内地址 分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码(不属于临 界资源),这样的代码是可以共享的。可修改的代码是不能共享的 

访问一个逻辑地址需要几次访存?

分页(单级页表):第一次访存ー一査内存中的页表,第二次访存ーー访问目标内存单元。总共两次访存

分段:第一次访存ー一査内存中的段表,第二次访存一一访问目标内存单元。总共两次访存。与分页系统类似,分段系统中也可以引入快表机构,将近期访问过的段表项放到快表中,这样可以少一次访问,加快地址变换速度。

![分段总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/分段总结.png)

## 段页式管理

（再看




![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/.jpeg)

![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/.png)





# 第三章 第二节 虚拟内存

内存空间的扩充：覆盖技术，交换技术，**虚拟存储技术**

![虚拟存储技术](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/虚拟存储技术.jpeg)

## 传统存储管理方式的特征、缺点

![传统存储管理方式的特征缺点](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/传统存储管理方式的特征缺点.jpeg)

* 一次性：作业必须一次性全部装入内存后才能运行，造成两个问题
  * 作业很大时，不能全部装入内存，这样就导致大作业无法运行
  * 当大量作业要求运行时，内存也无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降
  
* 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束，事实上，在一个时间段内，只需要访问作业的一小部分数据即可，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了内存资源。

## 局部性原理

依据局部性原理，提出了虚拟内存技术。

**时间局部性：** 如果执行了程序中的某条指令，那么不久后这条指令很可能会再次执行，如果某个数据被访问过，不久之后可能会再次被访问（因为程序中存在大量循环）

**空间局部性：** 如果程序访问了某个存储单元，不久之后，其附近的存储单元可能被访问（因为很多数据在内存中是被连续存放的，程序的指令也是在内存中按顺序存放的）

**如何应用**局部性原理：**高速缓冲技术**，将近期会频繁访问的数据放到更高速的存储器中，暂时用不到的放在更低速的存储器中。

![计算机中存储器的层次结构](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/计算机中存储器的层次结构.jpeg)

（快表机构可以将近期经常访问的页表项副本放到更高速的联想寄存器中）基于局部性原理：
* 在程序装入时，把程序中很快用到的部分装入内存，暂时用不到的放到外存。  
* 在程序执行时，当所访问信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。
* 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存
* 在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是**虚拟内存**

易混淆知识点：

虚拟内存的**最大容量**是由计算机的地址结构（CPU寻址范围）确定的

虚拟内存的**实际容量**=min（内存和外存容量之和，CPU寻址范围）

**例题：**

某计算机是32位的，按字节编址，内存大小为512MB，外存大小为2GB，则虚拟内存的**最大容量**为2^32B = 4GB

虚拟内存的**实际容量**为min（2^32B, 512MB+2GB) = 2.5GB

即：实际的物理内存大小并没有变，只是在逻辑上进行了扩充

## 虚拟内存的特征

**多次性：** 无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。

**对换性：** 在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出

**虚拟性：** 从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量

## 如何实现虚拟内存技术

虚拟内存技术，允许一个作业分多次掉入内存，如果采用连续分配方式，会不方便实现，因此虚拟内存的实现建立在**离散分配**的内存管理方式基础上

相似：

![如何实现虚拟内存技术](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/如何实现虚拟内存技术.jpeg)

区别：

在程序执行的过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存然后继续执行程序。-> “请求”调页或“请求”调段功能。

若内存不够，由操作系统负责将内存中暂时用不到的信息换出到外存。 -> 页面置换，段置换功能。

## 请求分页管理方式

请求分页存储管理和基本分页存储管理的主要区别：

1. 在程序执行过程中，当访问信息不在内存时，由操作系统负责将所需要的信息从外存调入内存，然后继续执行程序

    即：操作系统要提供**请求调页功能**，将缺失页面从外存调入到内存

2. 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。
    
    即：操作系统提供**页面置换功能**，将暂时用不到的页面换出到外存。

![请求分页管理方式](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/请求分页管理方式.jpeg)

### 页表机制

![页表机制](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/页表机制.jpeg)

### 缺页中断机构

![缺页中断机构](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/缺页中断机构.jpeg)

![缺页中断机构2](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/缺页中断机构2.jpeg)


### 地址变换机构

![地址变换机构](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/地址变换机构.png)

新增步骤：

1. 请求调页（查找页表项时进行判断）
2. 页面置换（需要时调入页面，但没有空闲内存块时进行
3. 需要修改请求页表中新增的表项

![地址变换机构2](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/地址变换机构2.png)

![请求分页中的地址变换过程](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/请求分页中的地址变换过程.png)

在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤：

查快表（未命中）-- 查慢表（发现未调入内存）-- 调页（调入的页面对应的表项会直接加入快表） -- 查快表（命中） -- 访问目标内存单元

### 总结

![请求分页管理方式](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/请求分页管理方式.png)

## 页面置换算法

回忆：”若内存空间不够，操作系统负责将内存中暂时用不到的信息换出到外存“ ————由页面置换算法来决定应该换出哪个页面

![页面置换算法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/页面置换算法.png)

由于页面的换入和换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率

### 最佳置换算法OPT

![最佳置换算法OPT](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/最佳置换算法OPT.png)

整个过程**缺页中断**发生了**9**次，**页面置换**发生了**6**次。缺页时未必发生页面置换，若还有可用的空闲内存块，就不用进行页面置换。

缺页率 = 9/20 = 45%

最佳置换算法是无法实现的，因为实际上无法预知接下来会访问到哪个页面。

### 先进先出置换算法FIFO

![先进先出置换算法FIFO](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/先进先出置换算法FIFO.png)

缺页次数9

假如分配内存块时缺页次数反而变成了10次：
**Belady异常**：当为进程分配的物理块增多时，缺页次数不减反增的异常现象

只有FIFO算法会造成Belady异常。另外，FIFO算法虽然简单，但是该算法与实际运行时的规律并不适应，因为先进入的页面也有可能最常被访问。因此算法性能差。

### 最近最久未使用置换算法LRU

![最近最久未使用置换算法LRU](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/最近最久未使用置换算法LRU.png)

该算法实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大

### 时钟置换算法CLOCK

![时钟置换算法CLOCK](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/时钟置换算法CLOCK.png)

### 改进型的时钟置换算法，也叫“二次机会法”

![改进型的时钟置换算法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/改进型的时钟置换算法.png)

优先级：

![改进型的时钟置换算法优先级](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/改进型的时钟置换算法优先级.png)

### 总结

![改进型的时钟置换算法总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/改进型的时钟置换算法总结.png)

## 页面分配策略

![页面分配策略](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/页面分配策略.png)

### 驻留集

指请求分页存储管理中给进程分配的物理块的集合。

在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。

若驻留集太小会导致缺页频繁，系统要花大量时间来处理缺页，实际用于进程推进的时间很少；

若驻留集太大又回导致缺页频繁，又会导致多道程序并发度下降，资源利用率降低。

**固定分配**：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即**驻留集大小不变**

**可变分配**：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少，即**驻留集大小可变**

**局部置换**：发生缺页时只能选进程自己的物理块进行置换。

**全局置换**：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

“全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配”

|     | 局部置换  | 全局置换  |
|  ----  | ----  | ----  |
| 固定分配  | 可 | NO  |
| 可变分配  | 可 | 可  |

### 页面分配、置换策略

**固定分配局部置换**：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变，若进程在运行中发生缺页

![页面分配置换策略](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/页面分配置换策略.jpeg)

可变分配全局置换：只要缺页就给分配新物理块

可变分配局部置换：要根据发生缺页的频率来动态增加或减少进程的物理块。

### 调入页面的时机

1. 预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面高效，但如果提前调入的页面中大部分都没有被访问过，则又是低效的。这种策略主要适用于**进程的首次调入————“运行前调入”**

2. 请求调页策略：进程在运行期间发现缺页时才将所缺页面调入内存。有这种策略调入的页面一定会被访问到，但由于每次只能调入一页，I/O开销比较大。**“运行时调入”**

### 从何处调入页面

![外存](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/外存.jpeg)

![对换区](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/对换区.jpeg)

![文件区](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/文件区.jpeg)

![UNIX方式](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/UNIX方式.jpeg)

### 抖动、颠簸现象

刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）

为进程分配的物理块太少,会使进程发生抖动现象。为进程分配的物理块太多,又会降低系统整体的并发度,降低某些资源的利用率

为了研究为应该为每个进程分配多个物理块, Denning提出了进程“工作集”的概念

### 工作集

**驻留集：** 指请求分页存储管理中给进程分配的内存块的集合。
**工作集：** 指在某段时间间隔里，进程实际访问页面的集合。

![工作集](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/工作集.png)、
工作集大小可能小于窗口尺寸,实际应用中,操作系统可以统计进程的工作集大小,根据工作集大小给进程分配若干内存块。如:窗口尺寸为5,经过一段时间的监测发现某进程的工作集最大为3,那么说明该进程有很好的局部性,可以给这个进程分配3个以上的内存块即可满足进程的运行需要。

一般来说,驻留集大小不能小于工作集大小,否则进程运行过程中将频繁缺页。

拓展:基于局部性原理可知,进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此,可以根据进程近期访问的页面集合(工作集)来设计一种页面置换算法ー一选择一个不在工作集中的页面进行淘汰。

![页面分配策略总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter3/页面分配策略总结.png)
# 第四章 第一节 

## 文件管理简介

作为系统资源的系统管理者，文件管理是操作系统提供的功能之一。
文件内部，文件之间如何组织？怎么能方便用户、应用程序使用文件？文件数据怎么存放在外存上？

### 文件的属性：

* 文件名：同一目录下不能有重名文件

* 标识符：一个系统内各个文件标识符唯一，对用户来说无可读性，只是操作系统使用的

* 类型

* 位置：文件存放路径，在外存中的地址

* 大小，创建时间，上次修改时间

* 保护信息：对文件进行保护的访问控制

### 文件内部数据怎样组织起来？

无结构文件，又称流式文件

有结构文件

![文件组织结构](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/文件组织结构.png)

### 文件之间的组织

“目录”

### 操作系统应该向上提供哪些共呢蝈 

创建文件，读文件，写文件，打开文件，关闭文件，删除文件

几个基本操作可以组成更复杂的操作，比如复制文件

### 文件如何存在外存？

和内存被分为内存块类似，外存也会被分为块/磁盘块/物理块，每个磁盘块大小相等，每块一般包含2的整数幂个地址。文件逻辑地址也可以被分为逻辑块号，块内地址。操作系统将逻辑地址转换为外存内的物理地址 

### 其他功能

文件共享，文件保护

## 文件的逻辑结构

逻辑结构：在用户看起来，文件内部数据结构如何组织起来

### 无结构文件

又称流式文件

### 有结构文件

又称记录式文件，由一组相似的记录组成，每一条记录又由若干个数据项组成。一般来说每条记录又一个数据项可以作为关键字，根据各条记录长度又可以分为定长记录和可变长记录。

 ![有结构文件逻辑结构](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/有结构文件逻辑结构.png)




### 顺序文件

文件中的记录一个接一个地顺序排列，分顺序存储和链式存储。顺序文件一般指物理上顺序存储的顺序文件，增加/删除一个记录比较困难

顺序文件：串结构，记录之间的顺序与关键字无关，通常按存入时间决定顺序；顺序结构：记录之间的顺序按照关键字排列。

能否随机存取，快速查找：

![顺序文件随机存取快速查找](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/顺序文件随机存取快速查找.png)


### 索引文件

对于可变长记录文件需要快速查找，如何解决？建立索引表加快文件检索速度，文件中的这些记录在物理上可以离散的存放。索引表本身是鼎昌的顺序文件 

### 索引顺序文件

索引文件的缺点：每个记录都对应一个索引表项，因此索引表可能太大。改进：**一组记录**对应一个索引表项，“分组的思想”。减少存储消耗，也减少了查找次数，直接在不重复的索引项里找就可以了，索引文件的索引表很多重复。

也可以继续建立多级索引表，成为**多级索引顺序文件**。

## 文件目录

![文件目录](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/文件目录.png)

### 文件控制块FCB

目录文件中的一条记录就是一个FCB，FCB中的有序集合称为文件目录，FCB包含了文件的基本信息（**文件名，物理地址**，逻辑结构，物理结构等），存取控制信息（可读？可写？禁止访问？），使用信息

需要对目录进行哪些操作？搜索，创建文件，删除文件，显示目录，修改目录

### 目录结构————单级目录结构

整个系统只有一张目录表，不允许文件重名

### 目录结构————两级目录结构

主文件目录MFD，用户文件目录UFD，允许不同用户的文件重名。

### 目录结构————多级目录结构（树形目录结构）

文件路径是个字符串，各级目录之间用“/”隔开，从根目录出发的路径称为绝对路径。系统根据绝对路径一层一层地找到下一级目录。

每次都从根目录找很低效，可以设置一个当前目录，从当前目录出发的“相对路径”，linux中用“.“表示当前目录


### 目录结构————无环图目录结构

树形结构层次结构清晰，但不方便文件共享，于是提出无环图目录结构

在树形结构的基础上增加一些指向同一节点的有向边，成为一个有向无环图。可以更方便地实现多个用户之间的文件共享。

这样可以用不同的文件名指向同一个文件，甚至指向同一目录。为了方便操作，设置共享计数器，删除文件时，只是删除该用的fcb，并使共享计数器减一

### 索引结点（FCB的改进）

 ![索引结点](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/索引结点.png)

除了文件名之外的所有信息都放在索引结点中，每个文件对应一个索引结点，目录项中只包含文件名，索引结点指针，因此每个目录项的长度大幅减小

## 文件的物理结构（文件的分配方式）

文件数据如何存放在外存中？对非空闲磁盘块的管理（存放了文件数据的磁盘块），对空闲磁盘块的管理

 ![文件的分配方式](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/文件的分配方式.png)

文件的逻辑地址被分为了一个一个的块，因此文件的逻辑地址也可以表示为 逻辑块号，块内地址。

### 连续分配方式

连续分配方式要求每个文件在磁盘上占有一组连续的块。 

逻辑地址到物理地址的映射：物理块号=起始块号+逻辑块号

读取某个磁盘块时，需要移动磁头，访问的两个磁盘块相隔越远，移动磁头所需要的时间越长。

结论：连续分配的文件在顺序读写时速度最快。不方便拓展，会产生磁盘碎片

### 链接分配

分显示链接和隐式链接

**隐式**：每个磁盘块都会保存指向下一个盘块的指针

只支持顺序访问，不支持随机访问，查找效率低，指针也消耗一定存储空间。

**显式**：把用于链接文件各个物理块的指针显式地存放在一张表中，即文件分配表FAT：file allocation table  

用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项。访问速度比较快。 

![链接分配总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/链接分配总结.png)

### 索引分配

索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块。

索引分配方式可以支持随机访问。也可以容易实现拓展，但是索引表会消耗空间。

如果一个硬盘块都装不下索引表，  

1. 链接方案：多个索引块链接起来存放

2. 多层索引

3. 混合索引 

### 总结

![总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/总结.png)

## 文件存储空间管理

![文件存储空间管理](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/文件存储空间管理.png)

### 存储空间的划分和初始化

将物理磁盘分为一个个文件卷

![存储空间的划分和初始化](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/存储空间的划分和初始化.png)

### 存储空间管理：空闲表法

分配磁盘块：首次适应，最佳适应，最坏适应法

回收磁盘块：和内存管理一样，也要注意表项的合并

### 存储空间管理：空闲链表法

空闲盘块链：以盘块为单位组成一条空闲链

空闲盘区链：以盘区为单位

盘区：连续的空闲 盘块组成一个空闲盘区

### 存储空间管理：位示图法

![位示图法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/位示图法.png)

0代表盘块空闲，1表示以分配


### 存储空间管理：成组链接法

linux采用的管理方式。
之前的策略组合起来，超级块：

### 总结

![存储空间管理总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/存储空间管理总结.png)

## 文件的基本操作

创建文件，删除文件，写文件，读文件，打开文件，关闭文件

### 创建文件：

![创建文件](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/创建文件.png)

### 删除文件

![删除文件](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/删除文件.png)

### 写文件

![写文件](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/写文件.png)

### 打开文件

![打开文件](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/打开文件.png)

### 关闭文件

![关闭文件](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/关闭文件.png)

### 读文件

![读文件](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/读文件.png)

### 总结

![文件操作总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/文件操作总结.png)

## 文件共享

![文件共享](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/文件共享.png)

### 基于索引的共享方式

回顾：索引结点

索引结点中设置一个链接计数变量count

### 基于链接的共享方式

快捷方式，链接一个路径信息

![文件共享总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/文件共享总结.png)

## 文件保护

口令保护，加密保护，访问控制

### 口令保护

为文件设置一个口令，用户请求访问该文件时需要提供口令，口令一般存在FCB或者索引结点中

优点：空间开销不多，验证口令的时间开销也很小

缺点：口令存放在系统中，不安全

### 加密保护

为文件设置密码。如异或加密。

![加密保护](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/加密保护.png)

### 访问控制

在每个文件的fcb或索引结点增加一个访问控制表（access control list），该表中记录了每个用户可以对该文件执行哪些操作（权限）。

![文件保护总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/文件保护总结.png)


## 文件系统的层次结构

![文件系统的层次结构](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/文件系统的层次结构.png)
# 第四章 第二节 磁盘

## 磁盘的结构

### 磁盘，磁道，扇区

磁盘的盘面被分为一个个的圈，就是磁道。一个磁道又被分为一个个的扇区。最内侧磁道的扇区面积最小，因此数据密度最大。

### 在磁盘中读取数据

把磁头移动到想要读写的扇区所在的磁道，磁盘旋转时，让目标扇区从此头下面划过，完成对磁盘扇区的读写工作。

### 磁盘的柱面，盘面

磁盘的物理地址：柱面号，盘面号，扇区号。

![磁盘的物理地址](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/磁盘的物理地址.jpeg)

### 磁盘的分类

活动头磁盘，固定头磁盘：这种磁盘中每个磁道都有对应的磁头

可换盘磁盘，固定盘磁盘

## 磁盘调度算法

![磁盘调度算法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/磁盘调度算法.jpeg)

### 一次磁盘读写操作的时间：

1. 寻找时间（寻道时间）Ts：

    * 启动磁头臂，耗时为s

    * 移动磁头臂，每跨越一道磁道耗时为m，总共跨越n条磁道

    * Ts = s + m * n

2. 延迟时间Tr：

    通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r，则平均所需的延迟时间为1/2r

3. 传输时间Tt：

    从磁盘读出或写入时间，假设磁盘转速weir，此次读写字节数为b，每个磁道上的字节数为N，则传输时间
    
    Tt=b/(r N)

Tr Tt是操作系统无法优化的，只和硬盘有关，因此只能优化磁盘调度算法

### FCFS

根据进程请求访问磁盘的先后顺序进行顺序。

### SSTF

贪心思想，会优先处理与当前磁头最近的磁道，保证每次寻道的时间最短，但是不能保证总的寻道时间最短。“眼前最优但是总体未必最优”，“饥饿现象”

### SCAN 扫描算法

SSTF产生饥饿的原因在于：随着进程不断进入，磁头可能只在同一个小区域内来回移动，为了防止这个现象，可以规定：只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧的时候才能向外移动。也称为”电梯算法“

**LOOK调度：**
边移动边观察，不用每次都移到最外边或最内边才掉头

### C-SCAN 循环扫描算法

SCAN算法对于各个位置磁道的响应频率不均，C-SCAN只在磁头朝某一个方向移动时才访问磁道，返回时直接快速移动到起始端而不处理任何请求。

### 总结

![磁盘调度算法总结](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/磁盘调度算法总结.jpeg)

## 减少延迟时间的方法

延迟时间：把目标扇区赚到磁头下面所花费的时间。

磁头独取一个扇区的内容后，需要一段时间进行处理，如果数据存入连续的几个扇区，会造成很大的延迟时间。

### 交替编号

让逻辑上相邻的扇区在物理上有一定的间隔。

### 错位命名

### 磁盘地址结构的设计

### 总结

![减少延迟时间的方法](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter4/减少延迟时间的方法.jpeg)

## 磁盘的管理

磁盘的管理：磁盘初始化，引导块，坏块的管理

### 磁盘初始化

1. 低级格式化（物理格式化），将磁盘的各个磁道划分为扇区，一个扇区常分为头、数据区、尾三个部分。

2. 将磁盘分区，每个分区由若干柱面组成（c盘，d盘，e盘等）

3. 进行逻辑格式化，创建文件系统

### 引导块

自举程序：计算机开机时需要通过执行初始化程序（自举程序）完成。ROM中存放很小的自举程序。完整的自举程序放在磁盘的启动块（引导块/启动分区）上，启动块位于磁盘的固定位置。

### 坏块的管理

无法正常使用的扇区就是坏块，硬件故障，操作系统无法修复，因此需要标记出来。磁盘控制器会维护一个坏块链表，并管理备用扇区。

# 第五章 IO设备

## I/O设备介绍

输入/输出设备。鼠标键盘，显示器，硬盘...

Unix系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作（Read,Write）操作

**I/O设备按使用特性分类**：人机交互类外部设备，存储设备，网络通信设备

**I/O设备按传输速率设备**：低速（鼠标键盘），中速（激光打印机），高速（磁盘）

**I/O设备按信息交换的单位分类**：块设备，字符设备

## I/O 控制器

机械部件，电子部件：io控制器和设备控制器

### I/Os控制器的功能

接受和识别cpu发出的指令，向CPU报告设备的状态，数据交换，地址识别。

![io控制器的功能](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter5/io控制器的功能.jpeg)

### IO控制器的组成

IO控制器和CPU的接口，IO逻辑，控制器和设备的接口。

![IO控制器的组成](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter5/IO控制器的组成.jpeg)






![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter5/.jpeg)

![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter5/.jpg)

![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter5/.JPG)

![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter5/.png)

![](https://github.com/nilshao/cpp-notebook/raw/master/operation_system/images/chapter5/.PNG)
































