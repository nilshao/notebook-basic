## 第7章 运行时刻环境

编译器必须准确实现源程序语言中包含的各个抽象概念，如名字，作用域，绑定，数据类型，运算符，过程，参数以及控制流构造。

本章两个主题是存储位置的分配和对变量及数据的访问。

### 存储组织

“代码区，静态区，堆-->（空闲内存）<--栈”

在很多机器中执行整数加法的指令可能要求整数是对齐的，也就是说这些数必须放在一个能够被4整除的地址上。
在c语言或者类似语言中一个有10个字符的数组只需要能够存放10个字符的空间，但是编译器为了对齐给他分配12字节（padding）。
空间比较紧张时编译器可能会压缩数据以消除padding。

代码区：生成的目标代码大小在编译时刻就已经固定下来了，因此编译器可以将可执行目标代码放在一个静态确定的区域：代码区。
这个区通常位于存储的低端。

静态区：程序的某些数据对象的大小可以在编译时刻知道，他们可以被放置在另一个称为静态区的区域中，该区域可以被静态确定。
放置在这个区域的数据对象包括全局常量和编译器产生的数据，比如用于支持垃圾回收的信息等。
要将尽可能多的数据进行静态分配，是因为这些对象的地址可以被编译到目标代码中

栈和堆：被放在剩余地址空间的相对两端，这些区域是动态的，根据需要向对方增长。

栈：用于存放“活动记录”，这些活动记录在函数调用过程中生成。


##### 静态和动态存储分配

静态和动态分别表示编译时刻和运行时刻。

编译器只需通过观察程序文本即可作出某个存储分配决定，而不需要观察该程序在运行时做了什么--->这个存储分配决定是静态的。

只有在程序运行时才做出决定--->动态：栈式存储，堆存储。

为了支持堆区管理，通过垃圾回收是的运行时刻系统能够检测出无用的数据元素，复用这些存储。

### 空间的栈式分配

#### 活动树

当过程调用在时间上不是嵌套的，栈式分配就不可行了，用一棵树来表示在整个程序运行期间的所有过程的活动（activation tree）树中每个节点对应于一个活动，根结点是启动程序执行的main过程的活动

#### 活动记录 

